{"version":3,"sources":["../node_modules/es6-promisify/dist/promisify.js","../node_modules/process/browser.js","../node_modules/path-browserify/index.js","path.js","shared.js","constants.js","../node_modules/base64-js/index.js","../node_modules/ieee754/index.js","../node_modules/isarray/index.js","../node_modules/buffer/index.js","providers/indexeddb.js","../lib/async.js","providers/memory.js","providers/index.js","errors.js","shell/environment.js","../node_modules/concat-map/index.js","../node_modules/balanced-match/index.js","../node_modules/brace-expansion/index.js","../node_modules/minimatch/minimatch.js","shell/shell.js","../lib/eventemitter.js","../lib/intercom.js","fs-watcher.js","directory-entry.js","open-files.js","node.js","open-file-description.js","super-node.js","stats.js","filesystem/implementation.js","filesystem/interface.js","index.js"],"names":["process","module","exports","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","setTimeout","e","clearTimeout","runTimeout","fun","call","runClearTimeout","marker","queue","draining","currentQueue","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","nextTick","args","Array","arguments","i","push","Item","array","prototype","apply","title","browser","env","argv","version","versions","noop","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","nodePath","require","filerPath","Object","create","basename","path","ext","normalize","removeTrailing","isNull","indexOf","addTrailing","replace","generateRandom","template","c","r","Math","random","v","toString","guid","toUpperCase","randomChars","n","repeat","nop","O_READ","O_WRITE","O_CREATE","O_EXCLUSIVE","O_TRUNCATE","O_APPEND","XATTR_CREATE","XATTR_REPLACE","FILE_SYSTEM_NAME","FILE_STORE_NAME","IDB_RO","IDB_RW","WSQL_VERSION","WSQL_SIZE","WSQL_DESC","NODE_TYPE_FILE","NODE_TYPE_DIRECTORY","NODE_TYPE_SYMBOLIC_LINK","NODE_TYPE_META","DEFAULT_DIR_PERMISSIONS","DEFAULT_FILE_PERMISSIONS","FULL_READ_WRITE_EXEC_PERMISSIONS","READ_WRITE_PERMISSIONS","SYMLOOP_MAX","BINARY_MIME_TYPE","JSON_MIME_TYPE","ROOT_DIRECTORY_NAME","FS_FORMAT","FS_NOCTIME","FS_NOMTIME","FS_NODUPEIDCHECK","O_FLAGS","FS_READY","FS_PENDING","FS_ERROR","SUPER_NODE_ID","STDIN","STDOUT","STDERR","FIRST_DESCRIPTOR","ENVIRONMENT","TMP","PATH","fsConstants","O_RDONLY","O_WRONLY","O_RDWR","S_IFMT","S_IFREG","S_IFDIR","S_IFCHR","S_IFBLK","S_IFIFO","S_IFLNK","S_IFSOCK","O_CREAT","O_EXCL","O_NOCTTY","O_TRUNC","O_DIRECTORY","O_NOFOLLOW","O_SYNC","O_DSYNC","O_SYMLINK","O_NONBLOCK","S_IRWXU","S_IRUSR","S_IWUSR","S_IXUSR","S_IRWXG","S_IRGRP","S_IWGRP","S_IXGRP","S_IRWXO","S_IROTH","S_IWOTH","S_IXOTH","F_OK","R_OK","W_OK","X_OK","UV_FS_COPYFILE_EXCL","COPYFILE_EXCL","IndexedDBContext","db","mode","_getObjectStore","objectStore","transaction","clear","callback","request","onsuccess","onerror","event","preventDefault","error","err","_get","key","get","result","target","getObject","getBuffer","arrayBuffer","Buffer","from","_put","value","put","putObject","putBuffer","uint8BackedBuffer","buf","buffer","delete","IndexedDB","isSupported","indexedDB","global","mozIndexedDB","webkitIndexedDB","msIndexedDB","open","that","openRequest","onupgradeneeded","objectStoreNames","contains","deleteObjectStore","createObjectStore","getReadOnlyContext","getReadWriteContext","async","setImmediate","fn","eachSeries","arr","iterator","completed","iterate","forEachSeries","define","amd","root","asyncCallback","createDB","pool","getOrCreate","hasOwnProperty","MemoryContext","readOnly","keys","forEach","Memory","Default","errors","split","errno","errName","defaultMessage","FilerError","msg","code","message","stack","constructor","pathInfo","defaults","Environment","set","promisify","Path","Errors","minimatch","Shell","fs","options","defineProperty","enumerable","cd","resolve","stat","stats","ENOTDIR","type","pwd","promises","methodName","bind","exec","sh","readFile","data","cmd","Function","touch","createFile","writeFile","updateTimes","now","Date","atime","date","mtime","utimes","updateOnly","cat","files","all","EINVAL","append","item","filename","ls","list","pathname","readdir","entries","getDirEntry","join","entry","recursive","items","contents","rm","remove","unlink","rmdir","ENOTEMPTY","map","tempDir","tmp","mkdir","mkdirp","_mkdirp","isDirectory","isFile","parent","dirname","find","next","found","processPath","maybeProcessPath","rawPath","regex","test","walk","removeItem","splice","EventEmitter","createInterface","space","methods","trigger","slice","self","pvt","_on","_off","_trigger","pub","unshift","throttle","delay","last","extend","a","b","localStorage","window","getItem","setItem","Intercom","origin","lastMessage","receivedIDs","previousValues","storageHandler","_onStorageEvent","document","attachEvent","addEventListener","_transaction","TIMEOUT","WAIT","executed","listening","waitTimer","lock","activeLock","INDEX_LOCK","unlock","_cleanup_emit","threshold","THRESHOLD_TTL_EMIT","changed","messages","JSON","parse","INDEX_EMIT","timestamp","stringify","_cleanup_once","ttl","table","INDEX_ONCE","_once_expired","THRESHOLD_TTL_ONCE","_localStorageChanged","field","currentValue","id","payload","_emit","String","packet","delimiter","substring","supported","destroy","getInstance","intercom","FSWatcher","recursivePathPrefix","onchange","start","filename_","persistent_","recursive_","close","DirectoryEntry","openFiles","getEmptyDescriptor","fd","getOpenFileDescription","ofd","allocDescriptor","openFileDescription","releaseDescriptor","ensureID","prop","generateMode","nodeType","modePermissions","Node","size","ctime","flags","xattrs","nlinks","permissions","uid","gid","OpenFileDescription","position","getNode","context","check_if_node_exists","node","EBADF","Constants","SuperNode","rnode","dateFromNumeric","num","Number","Stats","fileNode","devName","dev","atimeMs","mtimeMs","ctimeMs","isSymbolicLink","isSocket","isFIFO","isCharacterDevice","isBlockDevice","isAbsolutePath","isAbsolute","shared","update_node_times","times","includes","update","complete","changes","make_node","parentPath","parentNode","parentNodeData","create_node_in_parent","parentDirectoryNode","find_node","EEXIST","ENOENT","create_node","update_parent_node_data","update_time","followedCount","read_root_directory_node","nodeData","superNode","EFILESYSTEMERROR","check_root_directory_node","rootDirectoryNode","read_parent_directory_data","get_node_from_parent_directory_data","parentDirectoryData","nodeId","is_symbolic_link","ELOOP","follow_symbolic_link","set_extended_attribute","flag","ENOATTR","ensure_root_directory","directoryNode","directoryData","ensure_super_node","existingNode","write_directory_node","write_directory_data","make_directory","check_if_directory_exists","update_parent_directory_data","access_file","st_mode","validateAndMaskMode","EACCES","remove_directory","EBUSY","check_if_node_is_directory","check_if_directory_is_empty","remove_directory_entry_from_parent_directory_node","remove_directory_node","remove_directory_data","open_file","directoryEntry","fileData","EISDIR","set_file_node","read_directory_data","check_if_file_exists","check_if_symbolic_link","write_file_node","undefined","write_file_data","alloc","update_directory_data","handle_update_result","replace_data","offset","return_nbytes","update_file_node","newData","copy","write_data","update_file_data","EIO","_position","newSize","max","read_file_data","read_data","handle_file_data","stat_file","fstat_file","lstat_file","link_node","oldpath","newpath","oldname","oldParentPath","newname","newParentPath","oldDirectoryNode","oldDirectoryData","newDirectoryNode","newDirectoryData","fileNodeID","read_file_node","check_if_new_file_exists","read_new_directory_data","check_if_old_file_exists","EPERM","read_old_directory_data","unlink_node","delete_file_data","read_directory","handle_directory_data","make_symbolic_link","srcpath","dstpath","symlink_relpath","read_link","check_if_symbolic","truncate_file","truncate_file_data","ftruncate_file","utimes_file","update_times","futimes_file","setxattr_file","setxattr","fsetxattr_file","getxattr_file","get_xattr","fgetxattr_file","removexattr_file","remove_xattr","fremovexattr_file","validate_flags","validate_file_options","enc","fileMode","encoding","check_result","mknod","access","mkdtemp","prefix","fstat","link","read","wrapped_cb","bytesRead","fsync","validateInteger","cleanup","fstatResult","write","appendFile","exists","cb","octalReg","isUint32","def","isInteger","parsed","parseInt","chmod_file","update_mode","fchmod_file","chown_file","update_owner","fchown_file","getxattr","fgetxattr","fsetxattr","removexattr","fremovexattr","lseek","whence","update_descriptor_position","toUnixTimestamp","time","getTime","currentTime","futimes","chmod","fchmod","chown","fchown","rename","oldName","newName","oldParentDirectory","oldParentData","newParentDirectory","newParentData","read_new_directory","update_old_parent_directory_data","update_new_parent_directory_data","check_if_new_directory_exists","read_new_parent_directory_data","get_new_parent_directory","unlink_old_file","check_node_type","symlink","readlink","lstat","truncate","ftruncate","ensureRootDirectory","providers","defaultGuidFn","impl","maybeCallback","defaultCallback","console","toPathIfFileURL","fileURLOrPath","protocol","third","codePointAt","decodeURIComponent","toPathIfBuffer","bufferOrPath","isBuffer","validatePath","allowRelative","processPathArg","idx","FileSystem","provider","forceFormatting","readyState","stdin","stdout","stderr","constants","queueOrRun","operation","runQueued","watch","listener","watcher","wrappedGuidFn","guidWithCheck","broadcastChanges","change","wrappedContext","openReadWriteContext","openReadOnlyContext","absPathArgs","relPathArgs","method","shouldPromisify","lastArgIndex","missingCallback","pathArg","fnArgs","Filer"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnFA;AACA,IAAIA,OAAO,GAAGC,MAAM,CAACC,OAAP,GAAiB,EAA/B,EAEA;AACA;AACA;AACA;;AAEA,IAAIC,gBAAJ;AACA,IAAIC,kBAAJ;;AAEA,SAASC,gBAAT,GAA4B;AACxB,QAAM,IAAIC,KAAJ,CAAU,iCAAV,CAAN;AACH;;AACD,SAASC,mBAAT,GAAgC;AAC5B,QAAM,IAAID,KAAJ,CAAU,mCAAV,CAAN;AACH;;AACA,aAAY;AACT,MAAI;AACA,QAAI,OAAOE,UAAP,KAAsB,UAA1B,EAAsC;AAClCL,MAAAA,gBAAgB,GAAGK,UAAnB;AACH,KAFD,MAEO;AACHL,MAAAA,gBAAgB,GAAGE,gBAAnB;AACH;AACJ,GAND,CAME,OAAOI,CAAP,EAAU;AACRN,IAAAA,gBAAgB,GAAGE,gBAAnB;AACH;;AACD,MAAI;AACA,QAAI,OAAOK,YAAP,KAAwB,UAA5B,EAAwC;AACpCN,MAAAA,kBAAkB,GAAGM,YAArB;AACH,KAFD,MAEO;AACHN,MAAAA,kBAAkB,GAAGG,mBAArB;AACH;AACJ,GAND,CAME,OAAOE,CAAP,EAAU;AACRL,IAAAA,kBAAkB,GAAGG,mBAArB;AACH;AACJ,CAnBA,G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;;AAIAN,OAAO,CAACwD,GAAR,GAAc,YAAY;AAAE,SAAO,GAAP;AAAY,CAAxC;;AACAxD,OAAO,CAACyD,KAAR,GAAgB,UAAUC,GAAV,EAAe;AAC3B,QAAM,IAAIpD,KAAJ,CAAU,gCAAV,CAAN;AACH,CAFD;;AAGAN,OAAO,CAAC2D,KAAR,GAAgB,YAAW;AAAE,SAAO,CAAP;AAAW,CAAxC;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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AA,OAAO,EAAE,EA5BE;AA6BXC,IAAAA,OAAO,EAAE,EA7BE;AA8BXC,IAAAA,OAAO,EAAE,CA9BE;AA+BXC,IAAAA,OAAO,EAAE,CA/BE;AAgCXC,IAAAA,OAAO,EAAE,CAhCE;AAiCXC,IAAAA,OAAO,EAAE,CAjCE;AAkCXC,IAAAA,OAAO,EAAE,CAlCE;AAmCXC,IAAAA,IAAI,EAAE,CAnCK;AAoCXC,IAAAA,IAAI,EAAE,CApCK;AAqCXC,IAAAA,IAAI,EAAE,CArCK;AAsCXC,IAAAA,IAAI,EAAE,CAtCK;AAuCXC,IAAAA,mBAAmB,EAAE,CAvCV;AAwCXC,IAAAA,aAAa,EAAE;AAxCJ;AA9EE,CAAjB;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7vDA,IAAI1E,gBAAgB,GAAGnC,OAAO,CAAC,iBAAD,CAAP,CAA2BmC,gBAAlD;;AACA,IAAIC,eAAe,GAAGpC,OAAO,CAAC,iBAAD,CAAP,CAA2BoC,eAAjD;;AACA,IAAIE,MAAM,GAAGtC,OAAO,CAAC,iBAAD,CAAP,CAA2BsC,MAAxC;;AACA,IAAID,MAAM,GAAGrC,OAAO,CAAC,iBAAD,CAAP,CAA2BqC,MAAxC;;A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pB;;;AACAX,EAAAA,MAAM,CAACG,OAAD,CAAN,GAAkBH,MAAM,CAACE,KAAD,CAAN,GAAgBG,UAAlC;AACD,CApGD;AAsGAzP,MAAM,CAACC,OAAP,GAAiBmP,MAAjB;;ACvGA,IAAIY,QAAQ,GAAGpM,OAAO,CAAC,iBAAD,CAAP,CAA2BmE,WAA1C;;AAEA/H,MAAM,CAACC,OAAP,GAAiB,SAASgQ,WAAT,CAAqB3N,GAArB,EAA0B;AACzCA,EAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AACAA,EAAAA,GAAG,CAAC0F,GAAJ,GAAU1F,GAAG,CAAC0F,GAAJ,IAAWgI,QAAQ,CAAChI,GAA9B;AACA1F,EAAAA,GAAG,CAAC2F,IAAJ,GAAW3F,GAAG,CAAC2F,IAAJ,IAAY+H,QAAQ,CAAC/H,IAAhC;;AAEA,OAAK0D,GAAL,GAAW,UAAStI,IAAT,EAAe;AACxB,WAAOf,GAAG,CAACe,IAAD,CAAV;AACD,GAFD;;AAIA,OAAK6M,GAAL,GAAW,UAAS7M,IAAT,EAAe+I,KAAf,EAAsB;AAC/B9J,IAAAA,GAAG,CAACe,IAAD,CAAH,GAAY+I,KAAZ;AACD,GAFD;AAGD,CAZD;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;eC35BkBxI,OAAO,CAAC,eAAD;IAApBuM,qBAAAA;;AACL,IAAIC,IAAI,GAAGxM,OAAO,CAAC,YAAD,CAAlB;;AACA,IAAIyM,MAAM,GAAGzM,OAAO,CAAC,cAAD,CAApB;;AACA,IAAIqM,WAAW,GAAGrM,OAAO,CAAC,kBAAD,CAAzB;;AACA,IAAIiK,KAAK,GAAGjK,OAAO,CAAC,oBAAD,CAAnB;;AACA,IAAI0M,SAAS,GAAG1M,OAAO,CAAC,WAAD,CAAvB;;AAEA,SAAS2M,KAAT,CAAeC,EAAf,EAAmBC,OAAnB,EAA4B;AAAA;;AAC1BA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,MAAInO,GAAG,GAAG,IAAI2N,WAAJ,CAAgBQ,OAAO,CAACnO,GAAxB,CAAV;AACA,MAAIiB,GAAG,GAAG,GAAV;AAEA;;;;AAGAO,EAAAA,MAAM,CAAC4M,cAAP,CAAsB,IAAtB,EAA4B,IAA5B,EAAkC;AAChC/E,IAAAA,GAAG,EA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","file":"filer.map","sourceRoot":"..\\src","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// Symbols is a better way to do this, but not all browsers have good support,\n// so instead we'll just make do with a very unlikely string.\nvar customArgumentsToken = \"__ES6-PROMISIFY--CUSTOM-ARGUMENTS__\";\n\n/**\n * promisify()\n * Transforms callback-based function -- func(arg1, arg2 .. argN, callback) -- into\n * an ES6-compatible Promise. Promisify provides a default callback of the form (error, result)\n * and rejects when `error` is truthy.\n *\n * @param {function} original - The function to promisify\n * @return {function} A promisified version of `original`\n */\nfunction promisify(original) {\n\n    // Ensure the argument is a function\n    if (typeof original !== \"function\") {\n        throw new TypeError(\"Argument to promisify must be a function\");\n    }\n\n    // If the user has asked us to decode argument names for them, honour that\n    var argumentNames = original[customArgumentsToken];\n\n    // If the user has supplied a custom Promise implementation, use it. Otherwise\n    // fall back to whatever we can find on the global object.\n    var ES6Promise = promisify.Promise || Promise;\n\n    // If we can find no Promise implemention, then fail now.\n    if (typeof ES6Promise !== \"function\") {\n        throw new Error(\"No Promise implementation found; do you need a polyfill?\");\n    }\n\n    return function () {\n        var _this = this;\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        return new ES6Promise(function (resolve, reject) {\n\n            // Append the callback bound to the context\n            args.push(function callback(err) {\n\n                if (err) {\n                    return reject(err);\n                }\n\n                for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                    values[_key2 - 1] = arguments[_key2];\n                }\n\n                if (values.length === 1 || !argumentNames) {\n                    return resolve(values[0]);\n                }\n\n                var o = {};\n                values.forEach(function (value, index) {\n                    var name = argumentNames[index];\n                    if (name) {\n                        o[name] = value;\n                    }\n                });\n\n                resolve(o);\n            });\n\n            // Call the function.\n            original.call.apply(original, [_this].concat(args));\n        });\n    };\n}\n\n// Attach this symbol to the exported function, so users can use it\npromisify.argumentNames = customArgumentsToken;\npromisify.Promise = undefined;\n\n// Export the public API\nexports.promisify = promisify;","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","/**\n * Patch process to add process.cwd(), always giving the root dir.\n * NOTE: this line needs to happen *before* we require in `path`.\n */\nprocess.cwd = () => '/';\n\n/**\n * https://github.com/browserify/path-browserify via Parcel.\n * We use is as a base for our own Filer.Path, and patch/add\n * a few things we need for the browser environment.\n */\nconst nodePath = require('path');\nconst filerPath = Object.create(nodePath);\n\n/**\n * Patch path.basename() to return / vs. ''\n */\nfilerPath.basename = (path, ext) => {\n  const basename = nodePath.basename(path, ext);\n  return basename === '' ? '/' : basename;\n};\n\n/**\n * Patch path.normalize() to not add a trailing /\n */\nfilerPath.normalize = (path) => {\n  path = nodePath.normalize(path);\n  return path === '/' ? path : filerPath.removeTrailing(path);\n};\n\n/**\n * Add new utility method isNull() to path: check for null paths.\n */\nfilerPath.isNull = path => ('' + path).indexOf('\\u0000') !== -1;\n\n/**\n * Add new utility method addTrailing() to add trailing / without doubling to //.\n */\nfilerPath.addTrailing = path => path.replace(/\\/*$/, '/');\n\n/**\n * Add new utility method removeTrailing() to remove trailing /, dealing with multiple\n */\nfilerPath.removeTrailing = path => {\n  path = path.replace(/\\/*$/, '');\n  return path === '' ? '/' : path;\n};\n\nmodule.exports = filerPath;\n","function generateRandom(template) {\n  return template.replace(/[xy]/g, function(c) {\n    var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);\n    return v.toString(16);\n  });\n}\n\nfunction guid() {\n  return generateRandom('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx').toUpperCase();\n}\n\n/**\n * Generate a string of n random characters.  Defaults to n=6.\n */ \nfunction randomChars(n) {\n  n = n || 6;\n  var template = 'x'.repeat(n);\n  return generateRandom(template);\n}\n\nfunction nop() {}\n\nmodule.exports = {\n  guid: guid,\n  nop: nop,\n  randomChars: randomChars\n};\n","var O_READ = 'READ';\nvar O_WRITE = 'WRITE';\nvar O_CREATE = 'CREATE';\nvar O_EXCLUSIVE = 'EXCLUSIVE';\nvar O_TRUNCATE = 'TRUNCATE';\nvar O_APPEND = 'APPEND';\nvar XATTR_CREATE = 'CREATE';\nvar XATTR_REPLACE = 'REPLACE';\n\nmodule.exports = {\n  FILE_SYSTEM_NAME: 'local',\n\n  FILE_STORE_NAME: 'files',\n\n  IDB_RO: 'readonly',\n  IDB_RW: 'readwrite',\n\n  WSQL_VERSION: '1',\n  WSQL_SIZE: 5 * 1024 * 1024,\n  WSQL_DESC: 'FileSystem Storage',\n\n  NODE_TYPE_FILE: 'FILE',\n  NODE_TYPE_DIRECTORY: 'DIRECTORY',\n  NODE_TYPE_SYMBOLIC_LINK: 'SYMLINK',\n  NODE_TYPE_META: 'META',\n\n\n  DEFAULT_DIR_PERMISSIONS: 0x1ED, // 755\n  DEFAULT_FILE_PERMISSIONS: 0x1A4, // 644\n  FULL_READ_WRITE_EXEC_PERMISSIONS: 0x1FF, // 777\n  READ_WRITE_PERMISSIONS: 0x1B6, /// 666\n  \n  SYMLOOP_MAX: 10,\n\n  BINARY_MIME_TYPE: 'application/octet-stream',\n  JSON_MIME_TYPE: 'application/json',\n\n  ROOT_DIRECTORY_NAME: '/', // basename(normalize(path))\n\n  // FS Mount Flags\n  FS_FORMAT: 'FORMAT',\n  FS_NOCTIME: 'NOCTIME',\n  FS_NOMTIME: 'NOMTIME',\n  FS_NODUPEIDCHECK: 'FS_NODUPEIDCHECK',\n\n  // FS File Open Flags\n  O_READ: O_READ,\n  O_WRITE: O_WRITE,\n  O_CREATE: O_CREATE,\n  O_EXCLUSIVE: O_EXCLUSIVE,\n  O_TRUNCATE: O_TRUNCATE,\n  O_APPEND: O_APPEND,\n\n  O_FLAGS: {\n    'r': [O_READ],\n    'r+': [O_READ, O_WRITE],\n    'w': [O_WRITE, O_CREATE, O_TRUNCATE],\n    'w+': [O_WRITE, O_READ, O_CREATE, O_TRUNCATE],\n    'wx': [O_WRITE, O_CREATE, O_EXCLUSIVE, O_TRUNCATE],\n    'wx+': [O_WRITE, O_READ, O_CREATE, O_EXCLUSIVE, O_TRUNCATE],\n    'a': [O_WRITE, O_CREATE, O_APPEND],\n    'a+': [O_WRITE, O_READ, O_CREATE, O_APPEND],\n    'ax': [O_WRITE, O_CREATE, O_EXCLUSIVE, O_APPEND],\n    'ax+': [O_WRITE, O_READ, O_CREATE, O_EXCLUSIVE, O_APPEND]\n  },\n\n  XATTR_CREATE: XATTR_CREATE,\n  XATTR_REPLACE: XATTR_REPLACE,\n\n  FS_READY: 'READY',\n  FS_PENDING: 'PENDING',\n  FS_ERROR: 'ERROR',\n\n  SUPER_NODE_ID: '00000000-0000-0000-0000-000000000000',\n\n  // Reserved File Descriptors for streams\n  STDIN: 0,\n  STDOUT: 1,\n  STDERR: 2,\n  FIRST_DESCRIPTOR: 3,\n\n  ENVIRONMENT: {\n    TMP: '/tmp',\n    PATH: ''\n  },\n\n  // Duplicate Node's fs.constants\n  fsConstants: {\n    O_RDONLY: 0,\n    O_WRONLY: 1,\n    O_RDWR: 2,\n    S_IFMT: 61440,\n    S_IFREG: 32768,\n    S_IFDIR: 16384,\n    S_IFCHR: 8192,\n    S_IFBLK: 24576,\n    S_IFIFO: 4096,\n    S_IFLNK: 40960,\n    S_IFSOCK: 49152,\n    O_CREAT: 512,\n    O_EXCL: 2048,\n    O_NOCTTY: 131072,\n    O_TRUNC: 1024,\n    O_APPEND: 8,\n    O_DIRECTORY: 1048576,\n    O_NOFOLLOW: 256,\n    O_SYNC: 128,\n    O_DSYNC: 4194304,\n    O_SYMLINK: 2097152,\n    O_NONBLOCK: 4,\n    S_IRWXU: 448,\n    S_IRUSR: 256,\n    S_IWUSR: 128,\n    S_IXUSR: 64,\n    S_IRWXG: 56,\n    S_IRGRP: 32,\n    S_IWGRP: 16,\n    S_IXGRP: 8,\n    S_IRWXO: 7,\n    S_IROTH: 4,\n    S_IWOTH: 2,\n    S_IXOTH: 1,\n    F_OK: 0,\n    R_OK: 4,\n    W_OK: 2,\n    X_OK: 1,\n    UV_FS_COPYFILE_EXCL: 1,\n    COPYFILE_EXCL: 1\n  }\n};\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","var FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME;\nvar FILE_STORE_NAME = require('../constants.js').FILE_STORE_NAME;\nvar IDB_RW = require('../constants.js').IDB_RW;\nvar IDB_RO = require('../constants.js').IDB_RO;\n\nfunction IndexedDBContext(db, mode) {\n  this.db = db;\n  this.mode = mode;\n}\n\nIndexedDBContext.prototype._getObjectStore = function() {\n  if(this.objectStore) {\n    return this.objectStore;\n  }\n\n  var transaction = this.db.transaction(FILE_STORE_NAME, this.mode);\n  this.objectStore = transaction.objectStore(FILE_STORE_NAME);\n  return this.objectStore;\n};\n\nIndexedDBContext.prototype.clear = function(callback) {\n  try {\n    var objectStore = this._getObjectStore();\n    var request = objectStore.clear();\n    request.onsuccess = function() {\n      callback();\n    };\n    request.onerror = function(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\n\nIndexedDBContext.prototype._get = function(key, callback) {\n  try {\n    var objectStore = this._getObjectStore();\n    var request = objectStore.get(key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\nIndexedDBContext.prototype.getObject = function(key, callback) {\n  this._get(key, callback);\n};\nIndexedDBContext.prototype.getBuffer = function(key, callback) {\n  this._get(key, function(err, arrayBuffer) {\n    if(err) {\n      return callback(err);\n    }\n    callback(null, Buffer.from(arrayBuffer));\n  });\n};\n\nIndexedDBContext.prototype._put = function(key, value, callback) {\n  try {\n    var objectStore = this._getObjectStore();\n    var request = objectStore.put(value, key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\nIndexedDBContext.prototype.putObject = function(key, value, callback) {\n  this._put(key, value, callback);\n};\nIndexedDBContext.prototype.putBuffer = function(key, uint8BackedBuffer, callback) {\n  var buf = uint8BackedBuffer.buffer;\n  this._put(key, buf, callback);\n};\n\nIndexedDBContext.prototype.delete = function(key, callback) {\n  try {\n    var objectStore = this._getObjectStore();\n    var request = objectStore.delete(key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\n\n\nfunction IndexedDB(name) {\n  this.name = name || FILE_SYSTEM_NAME;\n  this.db = null;\n}\nIndexedDB.isSupported = function() {\n  var indexedDB = global.indexedDB       ||\n                  global.mozIndexedDB    ||\n                  global.webkitIndexedDB ||\n                  global.msIndexedDB;\n  return !!indexedDB;\n};\n\nIndexedDB.prototype.open = function(callback) {\n  var that = this;\n\n  // Bail if we already have a db open\n  if(that.db) {\n    return callback();\n  }\n\n  try {\n    var indexedDB = global.indexedDB       ||\n                    global.mozIndexedDB    ||\n                    global.webkitIndexedDB ||\n                    global.msIndexedDB;\n\n    // NOTE: we're not using versioned databases.\n    var openRequest = indexedDB.open(that.name);\n\n    // If the db doesn't exist, we'll create it\n    openRequest.onupgradeneeded = function onupgradeneeded(event) {\n      var db = event.target.result;\n\n      if(db.objectStoreNames.contains(FILE_STORE_NAME)) {\n        db.deleteObjectStore(FILE_STORE_NAME);\n      }\n      db.createObjectStore(FILE_STORE_NAME);\n    };\n\n    openRequest.onsuccess = function onsuccess(event) {\n      that.db = event.target.result;\n      callback();\n    };\n    openRequest.onerror = function onerror(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\n\nIndexedDB.prototype.getReadOnlyContext = function() {\n  return new IndexedDBContext(this.db, IDB_RO);\n};\nIndexedDB.prototype.getReadWriteContext = function() {\n  return new IndexedDBContext(this.db, IDB_RW);\n};\n\nmodule.exports = IndexedDB;\n","/*global setImmediate: false, setTimeout: false, console: false */\r\n\r\n/**\r\n * async.js shim, based on https://raw.github.com/caolan/async/master/lib/async.js Feb 18, 2014\r\n * Used under MIT - https://github.com/caolan/async/blob/master/LICENSE\r\n */\r\n\r\n(function () {\r\n\r\n    var async = {};\r\n\r\n    // async.js functions used in Filer\r\n\r\n    //// nextTick implementation with browser-compatible fallback ////\r\n    if (typeof process === 'undefined' || !(process.nextTick)) {\r\n        if (typeof setImmediate === 'function') {\r\n            async.nextTick = function (fn) {\r\n                // not a direct alias for IE10 compatibility\r\n                setImmediate(fn);\r\n            };\r\n            async.setImmediate = async.nextTick;\r\n        }\r\n        else {\r\n            async.nextTick = function (fn) {\r\n                setTimeout(fn, 0);\r\n            };\r\n            async.setImmediate = async.nextTick;\r\n        }\r\n    }\r\n    else {\r\n        async.nextTick = process.nextTick;\r\n        if (typeof setImmediate !== 'undefined') {\r\n            async.setImmediate = function (fn) {\r\n              // not a direct alias for IE10 compatibility\r\n              setImmediate(fn);\r\n            };\r\n        }\r\n        else {\r\n            async.setImmediate = async.nextTick;\r\n        }\r\n    }\r\n\r\n    async.eachSeries = function (arr, iterator, callback) {\r\n        callback = callback || function () {};\r\n        if (!arr.length) {\r\n            return callback();\r\n        }\r\n        var completed = 0;\r\n        var iterate = function () {\r\n            iterator(arr[completed], function (err) {\r\n                if (err) {\r\n                    callback(err);\r\n                    callback = function () {};\r\n                }\r\n                else {\r\n                    completed += 1;\r\n                    if (completed >= arr.length) {\r\n                        callback();\r\n                    }\r\n                    else {\r\n                        iterate();\r\n                    }\r\n                }\r\n            });\r\n        };\r\n        iterate();\r\n    };\r\n    async.forEachSeries = async.eachSeries;\r\n\r\n    // AMD / RequireJS\r\n    if (typeof define !== 'undefined' && define.amd) {\r\n        define([], function () {\r\n            return async;\r\n        });\r\n    }\r\n    // Node.js\r\n    else if (typeof module !== 'undefined' && module.exports) {\r\n        module.exports = async;\r\n    }\r\n    // included directly via <script> tag\r\n    else {\r\n        root.async = async;\r\n    }\r\n\r\n}());\r\n","var FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME;\n// NOTE: prefer setImmediate to nextTick for proper recursion yielding.\n// see https://github.com/js-platform/filer/pull/24\nvar asyncCallback = require('../../lib/async.js').setImmediate;\n\n/**\n * Make shared in-memory DBs possible when using the same name.\n */\nvar createDB = (function() {\n  var pool = {};\n  return function getOrCreate(name) {\n    if(!pool.hasOwnProperty(name)) {\n      pool[name] = {};\n    }\n    return pool[name];\n  };\n}());\n\nfunction MemoryContext(db, readOnly) {\n  this.readOnly = readOnly;\n  this.objectStore = db;\n}\n\nMemoryContext.prototype.clear = function(callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback('[MemoryContext] Error: write operation on read only context');\n    });\n    return;\n  }\n  var objectStore = this.objectStore;\n  Object.keys(objectStore).forEach(function(key){\n    delete objectStore[key];\n  });\n  asyncCallback(callback);\n};\n\n// Memory context doesn't care about differences between Object and Buffer\nMemoryContext.prototype.getObject =\nMemoryContext.prototype.getBuffer =\nfunction(key, callback) {\n  var that = this;\n  asyncCallback(function() {\n    callback(null, that.objectStore[key]);\n  });\n};\nMemoryContext.prototype.putObject =\nMemoryContext.prototype.putBuffer =\nfunction(key, value, callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback('[MemoryContext] Error: write operation on read only context');\n    });\n    return;\n  }\n  this.objectStore[key] = value;\n  asyncCallback(callback);\n};\n\nMemoryContext.prototype.delete = function(key, callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback('[MemoryContext] Error: write operation on read only context');\n    });\n    return;\n  }\n  delete this.objectStore[key];\n  asyncCallback(callback);\n};\n\n\nfunction Memory(name) {\n  this.name = name || FILE_SYSTEM_NAME;\n}\nMemory.isSupported = function() {\n  return true;\n};\n\nMemory.prototype.open = function(callback) {\n  this.db = createDB(this.name);\n  asyncCallback(callback);\n};\nMemory.prototype.getReadOnlyContext = function() {\n  return new MemoryContext(this.db, true);\n};\nMemory.prototype.getReadWriteContext = function() {\n  return new MemoryContext(this.db, false);\n};\n\nmodule.exports = Memory;\n","const IndexedDB = require('./indexeddb.js');\nconst Memory = require('./memory.js');\n\nmodule.exports = {\n  IndexedDB: IndexedDB,\n  Default: IndexedDB,\n  Memory: Memory\n};\n","var errors = {};\n[\n  /**\n   * node.js errors - we only use some of these, add as needed.\n   */\n  //'-1:UNKNOWN:unknown error',\n  //'0:OK:success',\n  //'1:EOF:end of file',\n  //'2:EADDRINFO:getaddrinfo error',\n  '3:EACCES:permission denied',\n  //'4:EAGAIN:resource temporarily unavailable',\n  //'5:EADDRINUSE:address already in use',\n  //'6:EADDRNOTAVAIL:address not available',\n  //'7:EAFNOSUPPORT:address family not supported',\n  //'8:EALREADY:connection already in progress',\n  '9:EBADF:bad file descriptor',\n  '10:EBUSY:resource busy or locked',\n  //'11:ECONNABORTED:software caused connection abort',\n  //'12:ECONNREFUSED:connection refused',\n  //'13:ECONNRESET:connection reset by peer',\n  //'14:EDESTADDRREQ:destination address required',\n  //'15:EFAULT:bad address in system call argument',\n  //'16:EHOSTUNREACH:host is unreachable',\n  //'17:EINTR:interrupted system call',\n  '18:EINVAL:invalid argument',\n  //'19:EISCONN:socket is already connected',\n  //'20:EMFILE:too many open files',\n  //'21:EMSGSIZE:message too long',\n  //'22:ENETDOWN:network is down',\n  //'23:ENETUNREACH:network is unreachable',\n  //'24:ENFILE:file table overflow',\n  //'25:ENOBUFS:no buffer space available',\n  //'26:ENOMEM:not enough memory',\n  '27:ENOTDIR:not a directory',\n  '28:EISDIR:illegal operation on a directory',\n  //'29:ENONET:machine is not on the network',\n  // errno 30 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js\n  //'31:ENOTCONN:socket is not connected',\n  //'32:ENOTSOCK:socket operation on non-socket',\n  //'33:ENOTSUP:operation not supported on socket',\n  '34:ENOENT:no such file or directory',\n  //'35:ENOSYS:function not implemented',\n  //'36:EPIPE:broken pipe',\n  //'37:EPROTO:protocol error',\n  //'38:EPROTONOSUPPORT:protocol not supported',\n  //'39:EPROTOTYPE:protocol wrong type for socket',\n  //'40:ETIMEDOUT:connection timed out',\n  //'41:ECHARSET:invalid Unicode character',\n  //'42:EAIFAMNOSUPPORT:address family for hostname not supported',\n  // errno 43 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js\n  //'44:EAISERVICE:servname not supported for ai_socktype',\n  //'45:EAISOCKTYPE:ai_socktype not supported',\n  //'46:ESHUTDOWN:cannot send after transport endpoint shutdown',\n  '47:EEXIST:file already exists',\n  //'48:ESRCH:no such process',\n  //'49:ENAMETOOLONG:name too long',\n  '50:EPERM:operation not permitted',\n  '51:ELOOP:too many symbolic links encountered',\n  //'52:EXDEV:cross-device link not permitted',\n  '53:ENOTEMPTY:directory not empty',\n  //'54:ENOSPC:no space left on device',\n  '55:EIO:i/o error',\n  //'56:EROFS:read-only file system',\n  //'57:ENODEV:no such device',\n  //'58:ESPIPE:invalid seek',\n  //'59:ECANCELED:operation canceled',\n\n  /**\n   * Filer specific errors\n   */\n  '1000:ENOTMOUNTED:not mounted',\n  '1001:EFILESYSTEMERROR:missing super node, use \\'FORMAT\\' flag to format filesystem.',\n  '1002:ENOATTR:attribute does not exist'\n\n].forEach(function(e) {\n  e = e.split(':');\n  var errno = +e[0];\n  var errName = e[1];\n  var defaultMessage = e[2];\n\n  function FilerError(msg, path) {\n    Error.call(this);\n\n    this.name = errName;\n    this.code = errName;\n    this.errno = errno;\n    this.message = msg || defaultMessage;\n    if(path) {\n      this.path = path;\n    }\n    this.stack = (new Error(this.message)).stack;\n  }\n  FilerError.prototype = Object.create(Error.prototype);\n  FilerError.prototype.constructor = FilerError;\n  FilerError.prototype.toString = function() {\n    var pathInfo = this.path ? (', \\'' + this.path + '\\'') : '';\n    return this.name + ': ' + this.message + pathInfo;\n  };\n\n  // We expose the error as both Errors.EINVAL and Errors[18]\n  errors[errName] = errors[errno] = FilerError;\n});\n\nmodule.exports = errors;\n","var defaults = require('../constants.js').ENVIRONMENT;\n\nmodule.exports = function Environment(env) {\n  env = env || {};\n  env.TMP = env.TMP || defaults.TMP;\n  env.PATH = env.PATH || defaults.PATH;\n\n  this.get = function(name) {\n    return env[name];\n  };\n\n  this.set = function(name, value) {\n    env[name] = value;\n  };\n};\n","module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","var concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n","module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n","var {promisify} = require('es6-promisify');\nvar Path = require('../path.js');\nvar Errors = require('../errors.js');\nvar Environment = require('./environment.js');\nvar async = require('../../lib/async.js');\nvar minimatch = require('minimatch');\n\nfunction Shell(fs, options) {\n  options = options || {};\n\n  var env = new Environment(options.env);\n  var cwd = '/';\n\n  /**\n   * The bound FileSystem (cannot be changed)\n   */\n  Object.defineProperty(this, 'fs', {\n    get: function() { return fs; },\n    enumerable: true\n  });\n\n  /**\n   * The shell's environment (e.g., for things like\n   * path, tmp, and other env vars). Use env.get()\n   * and env.set() to work with variables.\n   */\n  Object.defineProperty(this, 'env', {\n    get: function() { return env; },\n    enumerable: true\n  });\n\n  /**\n   * Change the current working directory. We\n   * include `cd` on the `this` vs. proto so that\n   * we can access cwd without exposing it externally.\n   */\n  this.cd = function(path, callback) {\n    path = Path.resolve(cwd, path);\n    // Make sure the path actually exists, and is a dir\n    fs.stat(path, function(err, stats) {\n      if(err) {\n        callback(new Errors.ENOTDIR(null, path));\n        return;\n      }\n      if(stats.type === 'DIRECTORY') {\n        cwd = path;\n        callback();\n      } else {\n        callback(new Errors.ENOTDIR(null, path));\n      }\n    });\n  };\n\n  /**\n   * Get the current working directory (changed with `cd()`)\n   */\n  this.pwd = function() {\n    return cwd;\n  };\n\n  this.promises = {};\n  /**\n  * Public API for Shell converted to Promise based\n  */\n  [\n    'cd',\n    'exec',\n    'touch',\n    'cat',\n    'ls',\n    'rm',\n    'tempDir',\n    'mkdirp',\n    'find'\n  ].forEach((methodName)=>{\n    this.promises[methodName] = promisify(this[methodName].bind(this));\n  });\n}\n\n/**\n * Execute the .js command located at `path`. Such commands\n * should assume the existence of 3 arguments, which will be\n * defined at runtime:\n *\n *   * fs - the current shell's bound filesystem object\n *   * args - a list of arguments for the command, or an empty list if none\n *   * callback - a callback function(error, result) to call when done.\n *\n * The .js command's contents should be the body of a function\n * that looks like this:\n *\n * function(fs, args, callback) {\n *   // .js code here\n * }\n */\nShell.prototype.exec = function(path, args, callback) {\n  /* jshint evil:true */\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof args === 'function') {\n    callback = args;\n    args = [];\n  }\n  args = args || [];\n  callback = callback || function(){};\n  path = Path.resolve(sh.pwd(), path);\n\n  fs.readFile(path, 'utf8', function(error, data) {\n    if(error) {\n      callback(error);\n      return;\n    }\n    try {\n      var cmd = new Function('fs', 'args', 'callback', data);\n      cmd(fs, args, callback);\n    } catch(e) {\n      callback(e);\n    }\n  });\n};\n\n/**\n * Create a file if it does not exist, or update access and\n * modified times if it does. Valid options include:\n *\n *  * updateOnly - whether to create the file if missing (defaults to false)\n *  * date - use the provided Date value instead of current date/time\n */\nShell.prototype.touch = function(path, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n  path = Path.resolve(sh.pwd(), path);\n\n  function createFile(path) {\n    fs.writeFile(path, '', callback);\n  }\n\n  function updateTimes(path) {\n    var now = Date.now();\n    var atime = options.date || now;\n    var mtime = options.date || now;\n\n    fs.utimes(path, atime, mtime, callback);\n  }\n\n  fs.stat(path, function(error) {\n    if(error) {\n      if(options.updateOnly === true) {\n        callback();\n      } else {\n        createFile(path);\n      }\n    } else {\n      updateTimes(path);\n    }\n  });\n};\n\n/**\n * Concatenate multiple files into a single String, with each\n * file separated by a newline. The `files` argument should\n * be a String (path to single file) or an Array of Strings\n * (multiple file paths).\n */\nShell.prototype.cat = function(files, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  var all = '';\n  callback = callback || function(){};\n\n  if(!files) {\n    callback(new Errors.EINVAL('Missing files argument'));\n    return;\n  }\n\n  files = typeof files === 'string' ? [ files ] : files;\n\n  function append(item, callback) {\n    var filename = Path.resolve(sh.pwd(), item);\n    fs.readFile(filename, 'utf8', function(error, data) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      all += data + '\\n';\n      callback();\n    });\n  }\n\n  async.eachSeries(files, append, function(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, all.replace(/\\n$/, ''));\n    }\n  });\n};\n\n/**\n * Get the listing of a directory, returning an array of\n * file entries in the following form:\n *\n * {\n *   path: <String> the basename of the directory entry\n *   links: <Number> the number of links to the entry\n *   size: <Number> the size in bytes of the entry\n *   modified: <Number> the last modified date/time\n *   type: <String> the type of the entry\n *   contents: <Array> an optional array of child entries\n * }\n *\n * By default ls() gives a shallow listing. If you want\n * to follow directories as they are encountered, use\n * the `recursive=true` option.\n */\nShell.prototype.ls = function(dir, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n\n  if(!dir) {\n    callback(new Errors.EINVAL('Missing dir argument'));\n    return;\n  }\n\n  function list(path, callback) {\n    var pathname = Path.resolve(sh.pwd(), path);\n    var result = [];\n\n    fs.readdir(pathname, function(error, entries) {\n      if(error) {\n        callback(error);\n        return;\n      }\n\n      function getDirEntry(name, callback) {\n        name = Path.join(pathname, name);\n        fs.stat(name, function(error, stats) {\n          if(error) {\n            callback(error);\n            return;\n          }\n          var entry = stats;\n\n          if(options.recursive && stats.type === 'DIRECTORY') {\n            list(Path.join(pathname, entry.name), function(error, items) {\n              if(error) {\n                callback(error);\n                return;\n              }\n              entry.contents = items;\n              result.push(entry);\n              callback();\n            });\n          } else {\n            result.push(entry);\n            callback();\n          }\n        });\n      }\n\n      async.eachSeries(entries, getDirEntry, function(error) {\n        callback(error, result);\n      });\n    });\n  }\n\n  list(dir, callback);\n};\n\n/**\n * Removes the file or directory at `path`. If `path` is a file\n * it will be removed. If `path` is a directory, it will be\n * removed if it is empty, otherwise the callback will receive\n * an error. In order to remove non-empty directories, use the\n * `recursive=true` option.\n */\nShell.prototype.rm = function(path, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n\n  if(!path) {\n    callback(new Errors.EINVAL('Missing path argument'));\n    return;\n  }\n\n  function remove(pathname, callback) {\n    pathname = Path.resolve(sh.pwd(), pathname);\n    fs.stat(pathname, function(error, stats) {\n      if(error) {\n        callback(error);\n        return;\n      }\n\n      // If this is a file, delete it and we're done\n      if(stats.type === 'FILE') {\n        fs.unlink(pathname, callback);\n        return;\n      }\n\n      // If it's a dir, check if it's empty\n      fs.readdir(pathname, function(error, entries) {\n        if(error) {\n          callback(error);\n          return;\n        }\n\n        // If dir is empty, delete it and we're done\n        if(entries.length === 0) {\n          fs.rmdir(pathname, callback);\n          return;\n        }\n\n        // If not, see if we're allowed to delete recursively\n        if(!options.recursive) {\n          callback(new Errors.ENOTEMPTY(null, pathname));\n          return;\n        }\n\n        // Remove each dir entry recursively, then delete the dir.\n        entries = entries.map(function(filename) {\n          // Root dir entries absolutely\n          return Path.join(pathname, filename);\n        });\n        async.eachSeries(entries, remove, function(error) {\n          if(error) {\n            callback(error);\n            return;\n          }\n          fs.rmdir(pathname, callback);\n        });\n      });\n    });\n  }\n\n  remove(path, callback);\n};\n\n/**\n * Gets the path to the temporary directory, creating it if not\n * present. The directory used is the one specified in\n * env.TMP. The callback receives (error, tempDirName).\n */\nShell.prototype.tempDir = function(callback) {\n  var sh = this;\n  var fs = sh.fs;\n  var tmp = sh.env.get('TMP');\n  callback = callback || function(){};\n\n  // Try and create it, and it will either work or fail\n  // but either way it's now there.\n  fs.mkdir(tmp, function() {\n    callback(null, tmp);\n  });\n};\n\n/**\n * Recursively creates the directory at `path`. If the parent\n * of `path` does not exist, it will be created.\n * Based off EnsureDir by Sam X. Xu\n * https://www.npmjs.org/package/ensureDir\n * MIT License\n */\nShell.prototype.mkdirp = function(path, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  callback = callback || function(){};\n\n  if(!path) {\n    callback(new Errors.EINVAL('Missing path argument'));\n    return;\n  }\n  else if (path === '/') {\n    callback();\n    return;\n  }\n  function _mkdirp(path, callback) {\n    fs.stat(path, function (err, stat) {\n      if(stat) {\n        if(stat.isDirectory()) {\n          callback();\n          return;\n        }\n        else if (stat.isFile()) {\n          callback(new Errors.ENOTDIR(null, path));\n          return;\n        }\n      }\n      else if (err && err.code !== 'ENOENT') {\n        callback(err);\n        return;\n      }\n      else {\n        var parent = Path.dirname(path);\n        if(parent === '/') {\n          fs.mkdir(path, function (err) {\n            if (err && err.code !== 'EEXIST') {\n              callback(err);\n              return;\n            }\n            callback();\n            return;\n          });\n        }\n        else {\n          _mkdirp(parent, function (err) {\n            if (err) return callback(err);\n            fs.mkdir(path, function (err) {\n              if (err && err.code !== 'EEXIST') {\n                callback(err);\n                return;\n              }\n              callback();\n              return;\n            });\n          });\n        }\n      }\n    });\n  }\n\n  _mkdirp(path, callback);\n};\n\n/**\n * Recursively walk a directory tree, reporting back all paths\n * that were found along the way. The `path` must be a dir.\n * Valid options include a `regex` for pattern matching paths\n * and an `exec` function of the form `function(path, next)` where\n * `path` is the current path that was found (dir paths have an '/'\n * appended) and `next` is a callback to call when done processing\n * the current path, passing any error object back as the first argument.\n * `find` returns a flat array of absolute paths for all matching/found\n * paths as the final argument to the callback.\n */\nShell.prototype.find = function(path, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n\n  var exec = options.exec || function(path, next) { next(); };\n  var found = [];\n\n  if(!path) {\n    callback(new Errors.EINVAL('Missing path argument'));\n    return;\n  }\n\n  function processPath(path, callback) {\n    exec(path, function(err) {\n      if(err) {\n        callback(err);\n        return;\n      }\n\n      found.push(path);\n      callback();\n    });\n  }\n\n  function maybeProcessPath(path, callback) {\n    // Test the path against the user's regex, name, path primaries (if any)\n    // and remove any trailing slashes added previously.\n    var rawPath = Path.removeTrailing(path);\n\n    // Check entire path against provided regex, if any\n    if(options.regex && !options.regex.test(rawPath)) {\n      callback();\n      return;\n    }\n\n    // Check basename for matches against name primary, if any\n    if(options.name && !minimatch(Path.basename(rawPath), options.name)) {\n      callback();\n      return;\n    }\n\n    // Check dirname for matches against path primary, if any\n    if(options.path && !minimatch(Path.dirname(rawPath), options.path)) {\n      callback();\n      return;\n    }\n\n    processPath(path, callback);\n  }\n\n  function walk(path, callback) {\n    path = Path.resolve(sh.pwd(), path);\n\n    // The path is either a file or dir, and instead of doing\n    // a stat() to determine it first, we just try to readdir()\n    // and it will either work or not, and we handle the non-dir error.\n    fs.readdir(path, function(err, entries) {\n      if(err) {\n        if(err.code === 'ENOTDIR' /* file case, ignore error */) {\n          maybeProcessPath(path, callback);\n        } else {\n          callback(err);\n        }\n        return;\n      }\n\n      // Path is really a dir, add a trailing / and report it found\n      maybeProcessPath(Path.addTrailing(path), function(err) {\n        if(err) {\n          callback(err);\n          return;\n        }\n\n        entries = entries.map(function(entry) {\n          return Path.join(path, entry);\n        });\n\n        async.eachSeries(entries, walk, function(err) {\n          callback(err, found);\n        });\n      });\n    });\n  }\n\n  // Make sure we are starting with a dir path\n  fs.stat(path, function(err, stats) {\n    if(err) {\n      callback(err);\n      return;\n    }\n    if(!stats.isDirectory()) {\n      callback(new Errors.ENOTDIR(null, path));\n      return;\n    }\n\n    walk(path, callback);\n  });\n};\n\nmodule.exports = Shell;\n","// Based on https://github.com/diy/intercom.js/blob/master/lib/events.js\r\n// Copyright 2012 DIY Co Apache License, Version 2.0\r\n// http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nfunction removeItem(item, array) {\r\n  for (var i = array.length - 1; i >= 0; i--) {\r\n    if (array[i] === item) {\r\n      array.splice(i, 1);\r\n    }\r\n  }\r\n  return array;\r\n}\r\n\r\nvar EventEmitter = function() {};\r\n\r\nEventEmitter.createInterface = function(space) {\r\n  var methods = {};\r\n\r\n  methods.on = function(name, fn) {\r\n    if (typeof this[space] === 'undefined') {\r\n      this[space] = {};\r\n    }\r\n    if (!this[space].hasOwnProperty(name)) {\r\n      this[space][name] = [];\r\n    }\r\n    this[space][name].push(fn);\r\n  };\r\n\r\n  methods.off = function(name, fn) {\r\n    if (typeof this[space] === 'undefined') return;\r\n    if (this[space].hasOwnProperty(name)) {\r\n      removeItem(fn, this[space][name]);\r\n    }\r\n  };\r\n\r\n  methods.trigger = function(name) {\r\n    if (typeof this[space] !== 'undefined' && this[space].hasOwnProperty(name)) {\r\n      var args = Array.prototype.slice.call(arguments, 1);\r\n      for (var i = 0; i < this[space][name].length; i++) {\r\n        this[space][name][i].apply(this[space][name][i], args);\r\n      }\r\n    }\r\n  };\r\n\r\n  methods.removeAllListeners = function(name) {\r\n    if (typeof this[space] === 'undefined') return;\r\n    var self = this;\r\n    self[space][name].forEach(function(fn) {\r\n      self.off(name, fn);\r\n    });\r\n  };\r\n\r\n  return methods;\r\n};\r\n\r\nvar pvt = EventEmitter.createInterface('_handlers');\r\nEventEmitter.prototype._on = pvt.on;\r\nEventEmitter.prototype._off = pvt.off;\r\nEventEmitter.prototype._trigger = pvt.trigger;\r\n\r\nvar pub = EventEmitter.createInterface('handlers');\r\nEventEmitter.prototype.on = function() {\r\n  pub.on.apply(this, arguments);\r\n  Array.prototype.unshift.call(arguments, 'on');\r\n  this._trigger.apply(this, arguments);\r\n};\r\nEventEmitter.prototype.off = pub.off;\r\nEventEmitter.prototype.trigger = pub.trigger;\r\nEventEmitter.prototype.removeAllListeners = pub.removeAllListeners;\r\n\r\nmodule.exports = EventEmitter;\r\n","// Based on https://github.com/diy/intercom.js/blob/master/lib/intercom.js\r\n// Copyright 2012 DIY Co Apache License, Version 2.0\r\n// http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nvar EventEmitter = require('./eventemitter.js');\r\nvar guid = require('../src/shared.js').guid;\r\n\r\nfunction throttle(delay, fn) {\r\n  var last = 0;\r\n  return function() {\r\n    var now = Date.now();\r\n    if (now - last > delay) {\r\n      last = now;\r\n      fn.apply(this, arguments);\r\n    }\r\n  };\r\n}\r\n\r\nfunction extend(a, b) {\r\n  if (typeof a === 'undefined' || !a) { a = {}; }\r\n  if (typeof b === 'object') {\r\n    for (var key in b) {\r\n      if (b.hasOwnProperty(key)) {\r\n        a[key] = b[key];\r\n      }\r\n    }\r\n  }\r\n  return a;\r\n}\r\n\r\nvar localStorage = (function(window) {\r\n  if (typeof window === 'undefined' ||\r\n      typeof window.localStorage === 'undefined') {\r\n    return {\r\n      getItem : function() {},\r\n      setItem : function() {},\r\n      removeItem : function() {}\r\n    };\r\n  }\r\n  return window.localStorage;\r\n}(global));\r\n\r\nfunction Intercom() {\r\n  var self = this;\r\n  var now = Date.now();\r\n\r\n  this.origin         = guid();\r\n  this.lastMessage    = now;\r\n  this.receivedIDs    = {};\r\n  this.previousValues = {};\r\n\r\n  var storageHandler = function() {\r\n    self._onStorageEvent.apply(self, arguments);\r\n  };\r\n\r\n  // If we're in node.js, skip event registration\r\n  if (typeof document === 'undefined') {\r\n    return;\r\n  }\r\n\r\n  if (document.attachEvent) {\r\n    document.attachEvent('onstorage', storageHandler);\r\n  } else {\r\n    global.addEventListener('storage', storageHandler, false);\r\n  }\r\n}\r\n\r\nIntercom.prototype._transaction = function(fn) {\r\n  var TIMEOUT   = 1000;\r\n  var WAIT      = 20;\r\n  var self      = this;\r\n  var executed  = false;\r\n  var listening = false;\r\n  var waitTimer = null;\r\n\r\n  function lock() {\r\n    if (executed) {\r\n      return;\r\n    }\r\n\r\n    var now = Date.now();\r\n    var activeLock = localStorage.getItem(INDEX_LOCK)|0;\r\n    if (activeLock && now - activeLock < TIMEOUT) {\r\n      if (!listening) {\r\n        self._on('storage', lock);\r\n        listening = true;\r\n      }\r\n      waitTimer = setTimeout(lock, WAIT);\r\n      return;\r\n    }\r\n    executed = true;\r\n    localStorage.setItem(INDEX_LOCK, now);\r\n\r\n    fn();\r\n    unlock();\r\n  }\r\n\r\n  function unlock() {\r\n    if (listening) {\r\n      self._off('storage', lock);\r\n    }\r\n    if (waitTimer) {\r\n      clearTimeout(waitTimer);\r\n    }\r\n    localStorage.removeItem(INDEX_LOCK);\r\n  }\r\n\r\n  lock();\r\n};\r\n\r\nIntercom.prototype._cleanup_emit = throttle(100, function() {\r\n  var self = this;\r\n\r\n  self._transaction(function() {\r\n    var now = Date.now();\r\n    var threshold = now - THRESHOLD_TTL_EMIT;\r\n    var changed = 0;\r\n    var messages;\r\n\r\n    try {\r\n      messages = JSON.parse(localStorage.getItem(INDEX_EMIT) || '[]');\r\n    } catch(e) {\r\n      messages = [];\r\n    }\r\n    for (var i = messages.length - 1; i >= 0; i--) {\r\n      if (messages[i].timestamp < threshold) {\r\n        messages.splice(i, 1);\r\n        changed++;\r\n      }\r\n    }\r\n    if (changed > 0) {\r\n      localStorage.setItem(INDEX_EMIT, JSON.stringify(messages));\r\n    }\r\n  });\r\n});\r\n\r\nIntercom.prototype._cleanup_once = throttle(100, function() {\r\n  var self = this;\r\n\r\n  self._transaction(function() {\r\n    var timestamp, ttl, key;\r\n    var table;\r\n    var now  = Date.now();\r\n    var changed = 0;\r\n\r\n    try {\r\n      table = JSON.parse(localStorage.getItem(INDEX_ONCE) || '{}');\r\n    } catch(e) {\r\n      table = {};\r\n    }\r\n    for (key in table) {\r\n      if (self._once_expired(key, table)) {\r\n        delete table[key];\r\n        changed++;\r\n      }\r\n    }\r\n\r\n    if (changed > 0) {\r\n      localStorage.setItem(INDEX_ONCE, JSON.stringify(table));\r\n    }\r\n  });\r\n});\r\n\r\nIntercom.prototype._once_expired = function(key, table) {\r\n  if (!table) {\r\n    return true;\r\n  }\r\n  if (!table.hasOwnProperty(key)) {\r\n    return true;\r\n  }\r\n  if (typeof table[key] !== 'object') {\r\n    return true;\r\n  }\r\n\r\n  var ttl = table[key].ttl || THRESHOLD_TTL_ONCE;\r\n  var now = Date.now();\r\n  var timestamp = table[key].timestamp;\r\n  return timestamp < now - ttl;\r\n};\r\n\r\nIntercom.prototype._localStorageChanged = function(event, field) {\r\n  if (event && event.key) {\r\n    return event.key === field;\r\n  }\r\n\r\n  var currentValue = localStorage.getItem(field);\r\n  if (currentValue === this.previousValues[field]) {\r\n    return false;\r\n  }\r\n  this.previousValues[field] = currentValue;\r\n  return true;\r\n};\r\n\r\nIntercom.prototype._onStorageEvent = function(event) {\r\n  event = event || global.event;\r\n  var self = this;\r\n\r\n  if (this._localStorageChanged(event, INDEX_EMIT)) {\r\n    this._transaction(function() {\r\n      var now = Date.now();\r\n      var data = localStorage.getItem(INDEX_EMIT);\r\n      var messages;\r\n\r\n      try {\r\n        messages = JSON.parse(data || '[]');\r\n      } catch(e) {\r\n        messages = [];\r\n      }\r\n      for (var i = 0; i < messages.length; i++) {\r\n        if (messages[i].origin === self.origin) continue;\r\n        if (messages[i].timestamp < self.lastMessage) continue;\r\n        if (messages[i].id) {\r\n          if (self.receivedIDs.hasOwnProperty(messages[i].id)) continue;\r\n          self.receivedIDs[messages[i].id] = true;\r\n        }\r\n        self.trigger(messages[i].name, messages[i].payload);\r\n      }\r\n      self.lastMessage = now;\r\n    });\r\n  }\r\n\r\n  this._trigger('storage', event);\r\n};\r\n\r\nIntercom.prototype._emit = function(name, message, id) {\r\n  id = (typeof id === 'string' || typeof id === 'number') ? String(id) : null;\r\n  if (id && id.length) {\r\n    if (this.receivedIDs.hasOwnProperty(id)) return;\r\n    this.receivedIDs[id] = true;\r\n  }\r\n\r\n  var packet = {\r\n    id        : id,\r\n    name      : name,\r\n    origin    : this.origin,\r\n    timestamp : Date.now(),\r\n    payload   : message\r\n  };\r\n\r\n  var self = this;\r\n  this._transaction(function() {\r\n    var data = localStorage.getItem(INDEX_EMIT) || '[]';\r\n    var delimiter = (data === '[]') ? '' : ',';\r\n    data = [data.substring(0, data.length - 1), delimiter, JSON.stringify(packet), ']'].join('');\r\n    localStorage.setItem(INDEX_EMIT, data);\r\n    self.trigger(name, message);\r\n\r\n    setTimeout(function() {\r\n      self._cleanup_emit();\r\n    }, 50);\r\n  });\r\n};\r\n\r\nIntercom.prototype.emit = function(name, message) {\r\n  this._emit.apply(this, arguments);\r\n  this._trigger('emit', name, message);\r\n};\r\n\r\nIntercom.prototype.once = function(key, fn, ttl) {\r\n  if (!Intercom.supported) {\r\n    return;\r\n  }\r\n\r\n  var self = this;\r\n  this._transaction(function() {\r\n    var data;\r\n    try {\r\n      data = JSON.parse(localStorage.getItem(INDEX_ONCE) || '{}');\r\n    } catch(e) {\r\n      data = {};\r\n    }\r\n    if (!self._once_expired(key, data)) {\r\n      return;\r\n    }\r\n\r\n    data[key] = {};\r\n    data[key].timestamp = Date.now();\r\n    if (typeof ttl === 'number') {\r\n      data[key].ttl = ttl * 1000;\r\n    }\r\n\r\n    localStorage.setItem(INDEX_ONCE, JSON.stringify(data));\r\n    fn();\r\n\r\n    setTimeout(function() {\r\n      self._cleanup_once();\r\n    }, 50);\r\n  });\r\n};\r\n\r\nextend(Intercom.prototype, EventEmitter.prototype);\r\n\r\nIntercom.supported = (typeof localStorage !== 'undefined');\r\n\r\nvar INDEX_EMIT = 'intercom';\r\nvar INDEX_ONCE = 'intercom_once';\r\nvar INDEX_LOCK = 'intercom_lock';\r\n\r\nvar THRESHOLD_TTL_EMIT = 50000;\r\nvar THRESHOLD_TTL_ONCE = 1000 * 3600;\r\n\r\nIntercom.destroy = function() {\r\n  localStorage.removeItem(INDEX_LOCK);\r\n  localStorage.removeItem(INDEX_EMIT);\r\n  localStorage.removeItem(INDEX_ONCE);\r\n};\r\n\r\nIntercom.getInstance = (function() {\r\n  var intercom;\r\n  return function() {\r\n    if (!intercom) {\r\n      intercom = new Intercom();\r\n    }\r\n    return intercom;\r\n  };\r\n})();\r\n\r\nmodule.exports = Intercom;\r\n","var EventEmitter = require('../lib/eventemitter.js');\nvar Path = require('./path.js');\nvar Intercom = require('../lib/intercom.js');\n\n/**\n * FSWatcher based on node.js' FSWatcher\n * see https://github.com/joyent/node/blob/master/lib/fs.js\n */\nfunction FSWatcher() {\n  EventEmitter.call(this);\n  var self = this;\n  var recursive = false;\n  var recursivePathPrefix;\n  var filename;\n\n  function onchange(path) {\n    // Watch for exact filename, or parent path when recursive is true.\n    if(filename === path || (recursive && path.indexOf(recursivePathPrefix) === 0)) {\n      self.trigger('change', 'change', path);\n    }\n  }\n\n  // We support, but ignore the second arg, which node.js uses.\n  self.start = function(filename_, persistent_, recursive_) {\n    // Bail if we've already started (and therefore have a filename);\n    if(filename) {\n      return;\n    }\n\n    if(Path.isNull(filename_)) {\n      throw new Error('Path must be a string without null bytes.');\n    }\n\n    // TODO: get realpath for symlinks on filename...\n\n    // Filer's Path.normalize strips trailing slashes, which we use here.\n    // See https://github.com/js-platform/filer/issues/105\n    filename = Path.normalize(filename_);\n\n    // Whether to watch beneath this path or not\n    recursive = recursive_ === true;\n    // If recursive, construct a path prefix portion for comparisons later\n    // (i.e., '/path' becomes '/path/' so we can search within a filename for the\n    // prefix). We also take care to allow for '/' on its own.\n    if(recursive) {\n      recursivePathPrefix = filename === '/' ? '/' : filename + '/';\n    }\n\n    var intercom = Intercom.getInstance();\n    intercom.on('change', onchange);\n  };\n\n  self.close = function() {\n    var intercom = Intercom.getInstance();\n    intercom.off('change', onchange);\n    self.removeAllListeners('change');\n  };\n}\nFSWatcher.prototype = new EventEmitter();\nFSWatcher.prototype.constructor = FSWatcher;\n\nmodule.exports = FSWatcher;\n","var NODE_TYPE_FILE = require('./constants.js').NODE_TYPE_FILE;\n\nmodule.exports = function DirectoryEntry(id, type) {\n  this.id = id;\n  this.type = type || NODE_TYPE_FILE;\n};\n","const { FIRST_DESCRIPTOR } = require('./constants');\nconst openFiles = {};\n\n/**\n * Start at FIRST_DESCRIPTOR and go until we find\n * an empty file descriptor, then return it.\n */\nconst getEmptyDescriptor = () => {\n  let fd = FIRST_DESCRIPTOR;\n\n  while(getOpenFileDescription(fd)) {\n    fd++;\n  }\n\n  return fd;\n};\n\n/**\n * Look up the open file description object for a given\n * file descriptor.\n */\nconst getOpenFileDescription = ofd => openFiles[ofd];\n\n/**\n * Allocate a new file descriptor for the given\n * open file description. \n */\nconst allocDescriptor = openFileDescription => {\n  const ofd = getEmptyDescriptor();\n  openFiles[ofd] = openFileDescription;\n  return ofd;\n};\n\n/**\n * Release the given existing file descriptor created\n * with allocDescriptor(). \n */\nconst releaseDescriptor = ofd => delete openFiles[ofd];\n\nmodule.exports = {\n  allocDescriptor,\n  releaseDescriptor,\n  getOpenFileDescription\n};\n","const {\n  NODE_TYPE_FILE,\n  NODE_TYPE_DIRECTORY,\n  NODE_TYPE_SYMBOLIC_LINK,\n  DEFAULT_FILE_PERMISSIONS,\n  DEFAULT_DIR_PERMISSIONS\n} = require('./constants');\nconst {\n  S_IFREG,\n  S_IFDIR,\n  S_IFLNK\n} = require('./constants').fsConstants;\n\n/**\n * Make sure the options object has an id on property,\n * either from caller or one we generate using supplied guid fn.\n */\nfunction ensureID(options, prop, callback) {\n  if(options[prop]) {\n    return callback();\n  }\n\n  options.guid(function(err, id) {\n    if(err) {\n      return callback(err);\n    }\n    options[prop] = id;\n    callback();\n  });\n}\n\n/**\n * Generate a POSIX mode (integer) for the node type and permissions.\n * Use default permissions if we aren't passed any.\n */\nfunction generateMode(nodeType, modePermissions) {\n  switch(nodeType) {\n  case NODE_TYPE_DIRECTORY:\n    return (modePermissions || DEFAULT_DIR_PERMISSIONS) | S_IFDIR;\n  case NODE_TYPE_SYMBOLIC_LINK:\n    return (modePermissions || DEFAULT_FILE_PERMISSIONS) | S_IFLNK;\n  case NODE_TYPE_FILE:\n    // falls through\n  default:\n    return (modePermissions || DEFAULT_FILE_PERMISSIONS) | S_IFREG;\n  }\n}\n\n/**\n * Common properties for the layout of a Node\n */\nclass Node {\n  constructor(options) {\n    var now = Date.now();\n\n    this.id = options.id;\n    this.data = options.data; // id for data object\n    this.size = options.size || 0; // size (bytes for files, entries for directories)\n    this.atime = options.atime || now; // access time (will mirror ctime after creation)\n    this.ctime = options.ctime || now; // creation/change time\n    this.mtime = options.mtime || now; // modified time\n    this.flags = options.flags || []; // file flags\n    this.xattrs = options.xattrs || {}; // extended attributes\n    this.nlinks = options.nlinks || 0; // links count\n\n    // Historically, Filer's node layout has referred to the\n    // node type as `mode`, and done so using a String.  In\n    // a POSIX filesystem, the mode is a number that combines\n    // both node type and permission bits. Internal we use `type`,\n    // but store it in the database as `mode` for backward\n    // compatibility.\n    if(typeof options.type === 'string') {\n      this.type = options.type;\n    } else if(typeof options.mode === 'string') {\n      this.type = options.mode;\n    } else {\n      this.type = NODE_TYPE_FILE;\n    }\n\n    // Extra mode permissions and ownership info\n    this.permissions = options.permissions || generateMode(this.type);\n    this.uid = options.uid || 0x0; // owner name\n    this.gid = options.gid || 0x0; // group name\n  }\n\n  /**\n   * Serialize a Node to JSON.  Everything is as expected except\n   * that we use `mode` for `type` to maintain backward compatibility.\n   */\n  toJSON() {\n    return {\n      id: this.id,\n      data: this.data,\n      size: this.size,\n      atime: this.atime,\n      ctime: this.ctime,\n      mtime: this.ctime,\n      flags: this.flags,\n      xattrs: this.xattrs,\n      nlinks: this.nlinks,\n      // Use `mode` for `type` to keep backward compatibility\n      mode: this.type,\n      permissions: this.permissions,\n      uid: this.uid,\n      gid: this.gid\n    };\n  }\n\n  // Return complete POSIX `mode` for node type + permissions. See:\n  // http://man7.org/linux/man-pages/man2/chmod.2.html\n  get mode() {\n    return generateMode(this.type, this.permissions);\n  }\n  // When setting the `mode` we assume permissions bits only (not changing type)\n  set mode(value) {\n    this.permissions = value;\n  }\n}\n\nmodule.exports.create = function create(options, callback) {\n  // We expect both options.id and options.data to be provided/generated.\n  ensureID(options, 'id', function(err) {\n    if(err) {\n      return callback(err);\n    }\n\n    ensureID(options, 'data', function(err) {\n      if(err) {\n        return callback(err);\n      }\n\n      callback(null, new Node(options));\n    });\n  });\n};\n","const Errors = require('./errors.js');\nconst Node = require('./node');\n\nfunction OpenFileDescription(path, id, flags, position) {\n  this.path = path;\n  this.id = id;\n  this.flags = flags;\n  this.position = position;\n}\n\n// Tries to find the node associated with an ofd's `id`.\n// If not found, an error is returned on the callback.\nOpenFileDescription.prototype.getNode = function(context, callback) {\n  var id = this.id;\n  var path = this.path;\n\n  function check_if_node_exists(error, node) {\n    if(error) {\n      return callback(error);\n    }\n\n    if(!node) {\n      return callback(new Errors.EBADF('file descriptor refers to unknown node', path));\n    }\n\n    Node.create(node, callback);\n  }\n\n  context.getObject(id, check_if_node_exists);\n};\n\nmodule.exports = OpenFileDescription;\n","var Constants = require('./constants.js');\n\nfunction SuperNode(options) {\n  var now = Date.now();\n\n  this.id = Constants.SUPER_NODE_ID;\n  this.type = Constants.NODE_TYPE_META;\n  this.atime = options.atime || now;\n  this.ctime = options.ctime || now;\n  this.mtime = options.mtime || now;\n  // root node id (randomly generated)\n  this.rnode = options.rnode;\n}\n\nSuperNode.create = function(options, callback) {\n  options.guid(function(err, rnode) {\n    if(err) {\n      callback(err);\n      return;\n    }\n    options.rnode = options.rnode || rnode;\n    callback(null, new SuperNode(options));\n  });\n};\n\nmodule.exports = SuperNode;\n","var Constants = require('./constants.js');\nvar Path = require('./path.js');\n\n// https://github.com/nodejs/node/blob/4f1297f259b09d129ac01afbd4c674263b7ac124/lib/internal/fs/utils.js#L231\nfunction dateFromNumeric(num) {\n  return new Date(Number(num) * 1000);\n}\n\nfunction Stats(path, fileNode, devName) {\n  this.dev = devName;\n  this.node = fileNode.id;\n  this.type = fileNode.type;\n  this.size = fileNode.size;\n  this.nlinks = fileNode.nlinks;\n  // Date objects\n  this.atime = dateFromNumeric(fileNode.atime);\n  this.mtime = dateFromNumeric(fileNode.mtime);\n  this.ctime = dateFromNumeric(fileNode.ctime);\n  // Unix timestamp Numbers\n  this.atimeMs = fileNode.atime;\n  this.mtimeMs = fileNode.mtime;\n  this.ctimeMs = fileNode.ctime;\n  this.version = fileNode.version;\n  this.mode = fileNode.mode;\n  this.uid = fileNode.uid;\n  this.gid = fileNode.gid;\n  this.name = Path.basename(path);\n}\n\nStats.prototype.isFile = function() {\n  return this.type === Constants.NODE_TYPE_FILE;\n};\n\nStats.prototype.isDirectory = function() {\n  return this.type === Constants.NODE_TYPE_DIRECTORY;\n};\n\nStats.prototype.isSymbolicLink = function() {\n  return this.type === Constants.NODE_TYPE_SYMBOLIC_LINK;\n};\n\n// These will always be false in Filer.\nStats.prototype.isSocket          =\nStats.prototype.isFIFO            =\nStats.prototype.isCharacterDevice =\nStats.prototype.isBlockDevice     =\nfunction() {\n  return false;\n};\n\nmodule.exports = Stats;\n","var Path = require('../path.js');\nvar normalize = Path.normalize;\nvar dirname = Path.dirname;\nvar basename = Path.basename;\nvar isAbsolutePath = Path.isAbsolute;\nvar shared = require('../shared.js');\n\nvar Constants = require('../constants.js');\nvar NODE_TYPE_FILE = Constants.NODE_TYPE_FILE;\nvar NODE_TYPE_DIRECTORY = Constants.NODE_TYPE_DIRECTORY;\nvar NODE_TYPE_SYMBOLIC_LINK = Constants.NODE_TYPE_SYMBOLIC_LINK;\nvar NODE_TYPE_META = Constants.NODE_TYPE_META;\n\nvar FULL_READ_WRITE_EXEC_PERMISSIONS = Constants.FULL_READ_WRITE_EXEC_PERMISSIONS;\n\nvar ROOT_DIRECTORY_NAME = Constants.ROOT_DIRECTORY_NAME;\nvar SUPER_NODE_ID = Constants.SUPER_NODE_ID;\nvar SYMLOOP_MAX = Constants.SYMLOOP_MAX;\n\nvar O_READ = Constants.O_READ;\nvar O_WRITE = Constants.O_WRITE;\nvar O_CREATE = Constants.O_CREATE;\nvar O_EXCLUSIVE = Constants.O_EXCLUSIVE;\nvar O_APPEND = Constants.O_APPEND;\nvar O_FLAGS = Constants.O_FLAGS;\n\nvar XATTR_CREATE = Constants.XATTR_CREATE;\nvar XATTR_REPLACE = Constants.XATTR_REPLACE;\nvar FS_NOMTIME = Constants.FS_NOMTIME;\nvar FS_NOCTIME = Constants.FS_NOCTIME;\n\nvar Errors = require('../errors.js');\nvar DirectoryEntry = require('../directory-entry.js');\nvar openFiles = require('../open-files.js');\nvar OpenFileDescription = require('../open-file-description.js');\nvar SuperNode = require('../super-node.js');\nvar Node = require('../node.js');\nvar Stats = require('../stats.js');\n\n/**\n * Update node times. Only passed times are modified (undefined times are ignored)\n * and filesystem flags are examined in order to override update logic.\n */\nfunction update_node_times(context, path, node, times, callback) {\n  // Honour mount flags for how we update times\n  var flags = context.flags;\n  if(flags.includes(FS_NOCTIME)) {\n    delete times.ctime;\n  }\n  if(flags.includes(FS_NOMTIME)) {\n    delete times.mtime;\n  }\n\n  // Only do the update if required (i.e., times are still present)\n  var update = false;\n  if(times.ctime) {\n    node.ctime = times.ctime;\n    // We don't do atime tracking for perf reasons, but do mirror ctime\n    node.atime = times.ctime;\n    update = true;\n  }\n  if(times.atime) {\n    // The only time we explicitly pass atime is when utimes(), futimes() is called.\n    // Override ctime mirror here if so\n    node.atime = times.atime;\n    update = true;\n  }\n  if(times.mtime) {\n    node.mtime = times.mtime;\n    update = true;\n  }\n\n  function complete(error) {\n    // Queue this change so we can send watch events.\n    // Unlike node.js, we send the full path vs. basename/dirname only.\n    context.changes.push({ event: 'change', path: path });\n    callback(error);\n  }\n\n  if(update) {\n    context.putObject(node.id, node, complete);\n  } else {\n    complete();\n  }\n}\n\n/**\n * make_node()\n */\n// in: file or directory path\n// out: new node representing file/directory\nfunction make_node(context, path, type, callback) {\n  if(type !== NODE_TYPE_DIRECTORY && type !== NODE_TYPE_FILE) {\n    return callback(new Errors.EINVAL('type must be a directory or file', path));\n  }\n\n  path = normalize(path);\n\n  var name = basename(path);\n  var parentPath = dirname(path);\n  var parentNode;\n  var parentNodeData;\n  var node;\n\n  // Check if the parent node exists\n  function create_node_in_parent(error, parentDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(parentDirectoryNode.type !== NODE_TYPE_DIRECTORY) {\n      callback(new Errors.ENOTDIR('a component of the path prefix is not a directory', path));\n    } else {\n      parentNode = parentDirectoryNode;\n      find_node(context, path, check_if_node_exists);\n    }\n  }\n\n  // Check if the node to be created already exists\n  function check_if_node_exists(error, result) {\n    if(!error && result) {\n      callback(new Errors.EEXIST('path name already exists', path));\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      context.getObject(parentNode.data, create_node);\n    }\n  }\n\n  // Create the new node\n  function create_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentNodeData = result;\n      Node.create({\n        guid: context.guid,\n        type: type\n      }, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        node = result;\n        node.nlinks += 1;\n        context.putObject(node.id, node, update_parent_node_data);\n      });\n    }\n  }\n\n  // Update parent node time\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, node, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  // Update the parent nodes data\n  function update_parent_node_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      parentNodeData[name] = new DirectoryEntry(node.id, type);\n      context.putObject(parentNode.data, parentNodeData, update_time);\n    }\n  }\n\n  // Find the parent node\n  find_node(context, parentPath, create_node_in_parent);\n}\n\n/**\n * find_node\n */\n// in: file or directory path\n// out: node structure, or error\nfunction find_node(context, path, callback) {\n  path = normalize(path);\n  if(!path) {\n    return callback(new Errors.ENOENT('path is an empty string'));\n  }\n  var name = basename(path);\n  var parentPath = dirname(path);\n  var followedCount = 0;\n\n  function read_root_directory_node(error, nodeData) {\n    if(error) {\n      return callback(error);\n    }\n\n    // Parse existing node as SuperNode\n    const superNode = new SuperNode(nodeData);\n\n    if(!superNode || superNode.type !== NODE_TYPE_META || !superNode.rnode) {\n      callback(new Errors.EFILESYSTEMERROR());\n    } else {\n      context.getObject(superNode.rnode, check_root_directory_node);\n    }\n  }\n\n  function check_root_directory_node(error, rootDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(!rootDirectoryNode) {\n      callback(new Errors.ENOENT());\n    } else {\n      Node.create(rootDirectoryNode, callback);\n    }\n  }\n\n  // in: parent directory node\n  // out: parent directory data\n  function read_parent_directory_data(error, parentDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(parentDirectoryNode.type !== NODE_TYPE_DIRECTORY || !parentDirectoryNode.data) {\n      callback(new Errors.ENOTDIR('a component of the path prefix is not a directory', path));\n    } else {\n      context.getObject(parentDirectoryNode.data, get_node_from_parent_directory_data);\n    }\n  }\n\n  // in: parent directory data\n  // out: searched node\n  function get_node_from_parent_directory_data(error, parentDirectoryData) {\n    if(error) {\n      callback(error);\n    } else {\n      if(!parentDirectoryData.hasOwnProperty(name)) {\n        callback(new Errors.ENOENT(null, path));\n      } else {\n        var nodeId = parentDirectoryData[name].id;\n        context.getObject(nodeId, create_node);\n      }\n    }\n  }\n\n  function create_node(error, data) {\n    if(error) {\n      return callback(error);\n    }\n    Node.create(data, is_symbolic_link);\n  }\n\n  function is_symbolic_link(error, node) {\n    if(error) {\n      callback(error);\n    } else {\n      if(node.type === NODE_TYPE_SYMBOLIC_LINK) {\n        followedCount++;\n        if(followedCount > SYMLOOP_MAX){\n          callback(new Errors.ELOOP(null, path));\n        } else {\n          follow_symbolic_link(node.data);\n        }\n      } else {\n        callback(null, node);\n      }\n    }\n  }\n\n  function follow_symbolic_link(data) {\n    data = normalize(data);\n    parentPath = dirname(data);\n    name = basename(data);\n    if(ROOT_DIRECTORY_NAME === name) {\n      context.getObject(SUPER_NODE_ID, read_root_directory_node);\n    } else {\n      find_node(context, parentPath, read_parent_directory_data);\n    }\n  }\n\n  if(ROOT_DIRECTORY_NAME === name) {\n    context.getObject(SUPER_NODE_ID, read_root_directory_node);\n  } else {\n    find_node(context, parentPath, read_parent_directory_data);\n  }\n}\n\n\n/**\n * set extended attribute (refactor)\n */\nfunction set_extended_attribute (context, path, node, name, value, flag, callback) {\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      update_node_times(context, path, node, { ctime: Date.now() }, callback);\n    }\n  }\n\n  var xattrs = node.xattrs;\n\n  if (flag === XATTR_CREATE && xattrs.hasOwnProperty(name)) {\n    callback(new Errors.EEXIST('attribute already exists', path));\n  }\n  else if (flag === XATTR_REPLACE && !xattrs.hasOwnProperty(name)) {\n    callback(new Errors.ENOATTR(null, path));\n  }\n  else {\n    xattrs[name] = value;\n    context.putObject(node.id, node, update_time);\n  }\n}\n\n/**\n * ensure_root_directory. Creates a root node if necessary.\n *\n * Note: this should only be invoked when formatting a new file system.\n * Multiple invocations of this by separate instances will still result\n * in only a single super node.\n */\nfunction ensure_root_directory(context, callback) {\n  var superNode;\n  var directoryNode;\n  var directoryData;\n\n  function ensure_super_node(error, existingNode) {\n    if(!error && existingNode) {\n      // Another instance has beat us and already created the super node.\n      callback();\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      SuperNode.create({guid: context.guid}, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        superNode = result;\n        context.putObject(superNode.id, superNode, write_directory_node);\n      });\n    }\n  }\n\n  function write_directory_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      Node.create({\n        guid: context.guid,\n        id: superNode.rnode,\n        type: NODE_TYPE_DIRECTORY\n      }, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        directoryNode = result;\n        directoryNode.nlinks += 1;\n        context.putObject(directoryNode.id, directoryNode, write_directory_data);\n      });\n    }\n  }\n\n  function write_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = {};\n      context.putObject(directoryNode.data, directoryData, callback);\n    }\n  }\n\n  context.getObject(SUPER_NODE_ID, ensure_super_node);\n}\n\n/**\n * make_directory\n */\nfunction make_directory(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var parentDirectoryNode;\n  var parentDirectoryData;\n\n  function check_if_directory_exists(error, result) {\n    if(!error && result) {\n      callback(new Errors.EEXIST(null, path));\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      find_node(context, parentPath, read_parent_directory_data);\n    }\n  }\n\n  function read_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryNode = result;\n      context.getObject(parentDirectoryNode.data, write_directory_node);\n    }\n  }\n\n  function write_directory_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryData = result;\n      Node.create({\n        guid: context.guid,\n        type: NODE_TYPE_DIRECTORY\n      }, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        directoryNode = result;\n        directoryNode.nlinks += 1;\n        context.putObject(directoryNode.id, directoryNode, write_directory_data);\n      });\n    }\n  }\n\n  function write_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = {};\n      context.putObject(directoryNode.data, directoryData, update_parent_directory_data);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, parentDirectoryNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_parent_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryData[name] = new DirectoryEntry(directoryNode.id, NODE_TYPE_DIRECTORY);\n      context.putObject(parentDirectoryNode.data, parentDirectoryData, update_time);\n    }\n  }\n\n  find_node(context, path, check_if_directory_exists);\n}\n\nfunction access_file(context, path, mode, callback) {\n  const { F_OK, R_OK, W_OK, X_OK, S_IXUSR, S_IXGRP, S_IXOTH } = Constants.fsConstants;\n\n  path = normalize(path);\n  find_node(context, path, function (err, node) {\n    if (err) {\n      return callback(err);\n    }\n\n    // If we have a node, F_OK is true.\n    if(mode === F_OK) {\n      return callback(null);\n    }\n\n    var st_mode = validateAndMaskMode(node.mode, callback);\n    if(!st_mode) return;\n\n    // For any other combo of F_OK, R_OK, W_OK, always allow. Filer user is a root user,\n    // so existing files are always OK, readable, and writable\n    if(mode & (R_OK | W_OK)) {\n      return callback(null);\n    }\n\n    // For the case of X_OK, actually check if this file is executable\n    if ((mode & X_OK) && (st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))) {\n      return callback(null);\n    }\n\n    // In any other case, the file isn't accessible\n    callback(new Errors.EACCES('permission denied',path)) ; \n  });\n}\n\n/**\n * remove_directory\n */\nfunction remove_directory(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var parentDirectoryNode;\n  var parentDirectoryData;\n\n  function read_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryNode = result;\n      context.getObject(parentDirectoryNode.data, check_if_node_exists);\n    }\n  }\n\n  function check_if_node_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else if(ROOT_DIRECTORY_NAME === name) {\n      callback(new Errors.EBUSY(null, path));\n    } else if(!result.hasOwnProperty(name)) {\n      callback(new Errors.ENOENT(null, path));\n    } else {\n      parentDirectoryData = result;\n      directoryNode = parentDirectoryData[name].id;\n      context.getObject(directoryNode, check_if_node_is_directory);\n    }\n  }\n\n  function check_if_node_is_directory(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.type !== NODE_TYPE_DIRECTORY) {\n      callback(new Errors.ENOTDIR(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_directory_is_empty);\n    }\n  }\n\n  function check_if_directory_is_empty(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(Object.keys(directoryData).length > 0) {\n        callback(new Errors.ENOTEMPTY(null, path));\n      } else {\n        remove_directory_entry_from_parent_directory_node();\n      }\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, parentDirectoryNode, { mtime: now, ctime: now }, remove_directory_node);\n    }\n  }\n\n  function remove_directory_entry_from_parent_directory_node() {\n    delete parentDirectoryData[name];\n    context.putObject(parentDirectoryNode.data, parentDirectoryData, update_time);\n  }\n\n  function remove_directory_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(directoryNode.id, remove_directory_data);\n    }\n  }\n\n  function remove_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(directoryNode.data, callback);\n    }\n  }\n\n  find_node(context, parentPath, read_parent_directory_data);\n}\n\nfunction open_file(context, path, flags, mode, callback) {\n  if (typeof mode === 'function'){\n    callback = mode;\n    mode = null;\n  }\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var directoryEntry;\n  var fileNode;\n  var fileData;\n\n  var followedCount = 0;\n\n  if(ROOT_DIRECTORY_NAME === name) {\n    if(flags.includes(O_WRITE)) {\n      callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n    } else {\n      find_node(context, path, set_file_node);\n    }\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.type !== NODE_TYPE_DIRECTORY) {\n      callback(new Errors.ENOENT(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(directoryData.hasOwnProperty(name)) {\n        if(flags.includes(O_EXCLUSIVE)) {\n          callback(new Errors.ENOENT('O_CREATE and O_EXCLUSIVE are set, and the named file exists', path));\n        } else {\n          directoryEntry = directoryData[name];\n          if(directoryEntry.type === NODE_TYPE_DIRECTORY && flags.includes(O_WRITE)) {\n            callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n          } else {\n            context.getObject(directoryEntry.id, check_if_symbolic_link);\n          }\n        }\n      } else {\n        if(!flags.includes(O_CREATE)) {\n          callback(new Errors.ENOENT('O_CREATE is not set and the named file does not exist', path));\n        } else {\n          write_file_node();\n        }\n      }\n    }\n  }\n\n  function check_if_symbolic_link(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var node = result;\n      if(node.type === NODE_TYPE_SYMBOLIC_LINK) {\n        followedCount++;\n        if(followedCount > SYMLOOP_MAX){\n          callback(new Errors.ELOOP(null, path));\n        } else {\n          follow_symbolic_link(node.data);\n        }\n      } else {\n        set_file_node(undefined, node);\n      }\n    }\n  }\n\n  function follow_symbolic_link(data) {\n    data = normalize(data);\n    parentPath = dirname(data);\n    name = basename(data);\n    if(ROOT_DIRECTORY_NAME === name) {\n      if(flags.includes(O_WRITE)) {\n        callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n      } else {\n        find_node(context, path, set_file_node);\n      }\n    }\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function set_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      callback(null, fileNode);\n    }\n  }\n\n  function write_file_node() {\n    Node.create({\n      guid: context.guid,\n      type: NODE_TYPE_FILE\n    }, function(error, result) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      fileNode = result;\n      fileNode.nlinks += 1;\n      if(mode){\n        fileNode.mode = mode;\n      }\n      context.putObject(fileNode.id, fileNode, write_file_data);\n    });\n  }\n\n  function write_file_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = Buffer.alloc(0);\n      context.putBuffer(fileNode.data, fileData, update_directory_data);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, handle_update_result);\n    }\n  }\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData[name] = new DirectoryEntry(fileNode.id, NODE_TYPE_FILE);\n      context.putObject(directoryNode.data, directoryData, update_time);\n    }\n  }\n\n  function handle_update_result(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, fileNode);\n    }\n  }\n}\n\nfunction replace_data(context, ofd, buffer, offset, length, callback) {\n  var fileNode;\n\n  function return_nbytes(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, length);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, return_nbytes);\n    }\n  }\n\n  function update_file_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function write_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n\n      var newData = Buffer.alloc(length);\n      buffer.copy(newData, 0, offset, offset + length);\n      ofd.position = length;\n\n      fileNode.size = length;\n      fileNode.version += 1;\n\n      context.putBuffer(fileNode.data, newData, update_file_node);\n    }\n  }\n\n  context.getObject(ofd.id, write_file_data);\n}\n\nfunction write_data(context, ofd, buffer, offset, length, position, callback) {\n  var fileNode;\n  var fileData;\n\n  function return_nbytes(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, length);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, return_nbytes);\n    }\n  }\n\n  function update_file_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function update_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = result;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var _position = (!(undefined === position || null === position)) ? position : ofd.position;\n      var newSize = Math.max(fileData.length, _position + length);\n      var newData = Buffer.alloc(newSize);\n      if(fileData) {\n        fileData.copy(newData);\n      }\n      buffer.copy(newData, _position, offset, offset + length);\n      if(undefined === position) {\n        ofd.position += length;\n      }\n\n      fileNode.size = newSize;\n      fileNode.version += 1;\n\n      context.putBuffer(fileNode.data, newData, update_file_node);\n    }\n  }\n\n  function read_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      context.getBuffer(fileNode.data, update_file_data);\n    }\n  }\n\n  context.getObject(ofd.id, read_file_data);\n}\n\nfunction read_data(context, ofd, buffer, offset, length, position, callback) {\n  var fileNode;\n  var fileData;\n\n  function handle_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = result;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var _position = (!(undefined === position || null === position)) ? position : ofd.position;\n      length = (_position + length > buffer.length) ? length - _position : length;\n      fileData.copy(buffer, offset, _position, _position + length);\n      if(undefined === position) {\n        ofd.position += length;\n      }\n      callback(null, length);\n    }\n  }\n\n  function read_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.type === NODE_TYPE_DIRECTORY) {\n      callback(new Errors.EISDIR('the named file is a directory', ofd.path));\n    } else {\n      fileNode = result;\n      context.getBuffer(fileNode.data, handle_file_data);\n    }\n  }\n\n  context.getObject(ofd.id, read_file_data);\n}\n\nfunction stat_file(context, path, callback) {\n  path = normalize(path);\n  find_node(context, path, callback);\n}\n\nfunction fstat_file(context, ofd, callback) {\n  ofd.getNode(context, callback);\n}\n\nfunction lstat_file(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n\n  if(ROOT_DIRECTORY_NAME === name) {\n    find_node(context, path, callback);\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!directoryData.hasOwnProperty(name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', path));\n      } else {\n        context.getObject(directoryData[name].id, callback);\n      }\n    }\n  }\n}\n\nfunction link_node(context, oldpath, newpath, callback) {\n  oldpath = normalize(oldpath);\n  var oldname = basename(oldpath);\n  var oldParentPath = dirname(oldpath);\n\n  newpath = normalize(newpath);\n  var newname = basename(newpath);\n  var newParentPath = dirname(newpath);\n  var ctime = Date.now();\n\n  var oldDirectoryNode;\n  var oldDirectoryData;\n  var newDirectoryNode;\n  var newDirectoryData;\n  var fileNodeID;\n  var fileNode;\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      update_node_times(context, newpath, fileNode, { ctime: ctime }, callback);\n    }\n  }\n\n  function update_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      fileNode.nlinks += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function read_file_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.getObject(fileNodeID, update_file_node);\n    }\n  }\n\n  function check_if_new_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newDirectoryData = result;\n      if(newDirectoryData.hasOwnProperty(newname)) {\n        callback(new Errors.EEXIST('newpath resolves to an existing file', newname));\n      } else {\n        newDirectoryData[newname] = oldDirectoryData[oldname];\n        fileNodeID = newDirectoryData[newname].id;\n        context.putObject(newDirectoryNode.data, newDirectoryData, read_file_node);\n      }\n    }\n  }\n\n  function read_new_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newDirectoryNode = result;\n      context.getObject(newDirectoryNode.data, check_if_new_file_exists);\n    }\n  }\n\n  function check_if_old_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldDirectoryData = result;\n      if(!oldDirectoryData.hasOwnProperty(oldname)) {\n        callback(new Errors.ENOENT('a component of either path prefix does not exist', oldname));\n      } else if(oldDirectoryData[oldname].type === NODE_TYPE_DIRECTORY) {\n        callback(new Errors.EPERM('oldpath refers to a directory'));\n      } else {\n        find_node(context, newParentPath, read_new_directory_data);\n      }\n    }\n  }\n\n  function read_old_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldDirectoryNode = result;\n      context.getObject(oldDirectoryNode.data, check_if_old_file_exists);\n    }\n  }\n\n  find_node(context, oldParentPath, read_old_directory_data);\n}\n\nfunction unlink_node(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var fileNode;\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      delete directoryData[name];\n      context.putObject(directoryNode.data, directoryData, function(error) {\n        if(error) {\n          callback(error);\n        } else {\n          var now = Date.now();\n          update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, callback);\n        }\n      });\n    }\n  }\n\n  function delete_file_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(fileNode.data, update_directory_data);\n    }\n  }\n\n  function update_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      fileNode.nlinks -= 1;\n      if(fileNode.nlinks < 1) {\n        context.delete(fileNode.id, delete_file_data);\n      } else {\n        context.putObject(fileNode.id, fileNode, function(error) {\n          if(error) {\n            callback(error);\n          } else {          \n            update_node_times(context, path, fileNode, { ctime: Date.now() }, update_directory_data);\n          }\n        });\n      }\n    }\n  }\n\n  function check_if_node_is_directory(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.type === NODE_TYPE_DIRECTORY) {\n      callback(new Errors.EPERM('unlink not permitted on directories', name));\n    } else {\n      update_file_node(null, result);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!directoryData.hasOwnProperty(name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', name));\n      } else {\n        context.getObject(directoryData[name].id, check_if_node_is_directory);\n      }\n    }\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  find_node(context, parentPath, read_directory_data);\n}\n\nfunction read_directory(context, path, callback) {\n  path = normalize(path);\n\n  var directoryNode;\n  var directoryData;\n\n  function handle_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      var files = Object.keys(directoryData);\n      callback(null, files);\n    }\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.type !== NODE_TYPE_DIRECTORY) {\n      callback(new Errors.ENOTDIR(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, handle_directory_data);\n    }\n  }\n\n  find_node(context, path, read_directory_data);\n}\n\nfunction make_symbolic_link(context, srcpath, dstpath, callback) {\n  dstpath = normalize(dstpath);\n  var name = basename(dstpath);\n  var parentPath = dirname(dstpath);\n\n  var directoryNode;\n  var directoryData;\n  var fileNode;\n\n  if(ROOT_DIRECTORY_NAME === name) {\n    callback(new Errors.EEXIST(null, name));\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(directoryData.hasOwnProperty(name)) {\n        callback(new Errors.EEXIST(null, name));\n      } else {\n        write_file_node();\n      }\n    }\n  }\n\n  function write_file_node() {\n    Node.create({\n      guid: context.guid,\n      type: NODE_TYPE_SYMBOLIC_LINK\n    }, function(error, result) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      fileNode = result;\n      fileNode.nlinks += 1;\n\n      // If the srcpath isn't absolute, resolve it relative to the dstpath\n      // but store both versions, since we'll use the relative one in readlink().\n      if(!isAbsolutePath(srcpath)) {\n        fileNode.symlink_relpath = srcpath;\n        srcpath = Path.resolve(parentPath, srcpath); \n      }\n\n      fileNode.size = srcpath.length;\n      fileNode.data = srcpath;\n      \n      context.putObject(fileNode.id, fileNode, update_directory_data);\n    });\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData[name] = new DirectoryEntry(fileNode.id, NODE_TYPE_SYMBOLIC_LINK);\n      context.putObject(directoryNode.data, directoryData, update_time);\n    }\n  }\n}\n\nfunction read_link(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n\n  find_node(context, parentPath, read_directory_data);\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!directoryData.hasOwnProperty(name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', name));\n      } else {\n        context.getObject(directoryData[name].id, check_if_symbolic);\n      }\n    }\n  }\n\n  function check_if_symbolic(error, fileNode) {\n    if(error) {\n      callback(error);\n    } else {\n      if(fileNode.type !== NODE_TYPE_SYMBOLIC_LINK) {\n        callback(new Errors.EINVAL('path not a symbolic link', path));\n      } else {\n        // If we were originally given a relative path, return that now vs. the\n        // absolute path we've generated and use elsewhere internally.\n        var target = fileNode.symlink_relpath ? fileNode.symlink_relpath : fileNode.data;\n        callback(null, target);\n      }\n    }\n  }\n}\n\nfunction truncate_file(context, path, length, callback) {\n  path = normalize(path);\n\n  var fileNode;\n\n  function read_file_data (error, node) {\n    if (error) {\n      callback(error);\n    } else if(node.type === NODE_TYPE_DIRECTORY ) {\n      callback(new Errors.EISDIR(null, path));\n    } else{\n      fileNode = node;\n      context.getBuffer(fileNode.data, truncate_file_data);\n    }\n  }\n\n  function truncate_file_data(error, fileData) {\n    if (error) {\n      callback(error);\n    } else {\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var data = Buffer.alloc(length);\n      if(fileData) {\n        fileData.copy(data);\n      }\n      context.putBuffer(fileNode.data, data, update_file_node);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, path, fileNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_file_node (error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode.size = length;\n      fileNode.version += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  if(length < 0) {\n    callback(new Errors.EINVAL('length cannot be negative'));\n  } else {\n    find_node(context, path, read_file_data);\n  }\n}\n\nfunction ftruncate_file(context, ofd, length, callback) {\n  var fileNode;\n\n  function read_file_data (error, node) {\n    if (error) {\n      callback(error);\n    } else if(node.type === NODE_TYPE_DIRECTORY ) {\n      callback(new Errors.EISDIR());\n    } else{\n      fileNode = node;\n      context.getBuffer(fileNode.data, truncate_file_data);\n    }\n  }\n\n  function truncate_file_data(error, fileData) {\n    if (error) {\n      callback(error);\n    } else {\n      var data;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      if(fileData) {\n        data = fileData.slice(0, length);\n      } else {\n        data = Buffer.alloc(length);\n      }\n      context.putBuffer(fileNode.data, data, update_file_node);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_file_node (error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode.size = length;\n      fileNode.version += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  if(length < 0) {\n    callback(new Errors.EINVAL('length cannot be negative'));\n  } else {\n    ofd.getNode(context, read_file_data);\n  }\n}\n\nfunction utimes_file(context, path, atime, mtime, callback) {\n  path = normalize(path);\n\n  function update_times(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      update_node_times(context, path, node, { atime: atime, ctime: mtime, mtime: mtime }, callback);\n    }\n  }\n\n  if (typeof atime !== 'number' || typeof mtime !== 'number') {\n    callback(new Errors.EINVAL('atime and mtime must be number', path));\n  }\n  else if (atime < 0 || mtime < 0) {\n    callback(new Errors.EINVAL('atime and mtime must be positive integers', path));\n  }\n  else {\n    find_node(context, path, update_times);\n  }\n}\n\nfunction futimes_file(context, ofd, atime, mtime, callback) {\n\n  function update_times (error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      update_node_times(context, ofd.path, node, { atime: atime, ctime: mtime, mtime: mtime }, callback);\n    }\n  }\n\n  if (typeof atime !== 'number' || typeof mtime !== 'number') {\n    callback(new Errors.EINVAL('atime and mtime must be a number'));\n  }\n  else if (atime < 0 || mtime < 0) {\n    callback(new Errors.EINVAL('atime and mtime must be positive integers'));\n  }\n  else {\n    ofd.getNode(context, update_times);\n  }\n}\n\nfunction setxattr_file(context, path, name, value, flag, callback) {\n  path = normalize(path);\n\n  function setxattr(error, node) {\n    if(error) {\n      return callback(error);\n    }\n    set_extended_attribute(context, path, node, name, value, flag, callback);\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else if (flag !== null &&\n           flag !== XATTR_CREATE && flag !== XATTR_REPLACE) {\n    callback(new Errors.EINVAL('invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE', path));\n  }\n  else {\n    find_node(context, path, setxattr);\n  }\n}\n\nfunction fsetxattr_file (context, ofd, name, value, flag, callback) {\n  function setxattr(error, node) {\n    if(error) {\n      return callback(error);\n    }\n    set_extended_attribute(context, ofd.path, node, name, value, flag, callback);\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string'));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else if (flag !== null &&\n           flag !== XATTR_CREATE && flag !== XATTR_REPLACE) {\n    callback(new Errors.EINVAL('invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE'));\n  }\n  else {\n    ofd.getNode(context, setxattr);\n  }\n}\n\nfunction getxattr_file (context, path, name, callback) {\n  path = normalize(path);\n\n  function get_xattr(error, node) {\n    if(error) {\n      return callback(error);\n    }\n\n    var xattrs = node.xattrs;\n\n    if (!xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR(null, path));\n    }\n    else {\n      callback(null, xattrs[name]);\n    }\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else {\n    find_node(context, path, get_xattr);\n  }\n}\n\nfunction fgetxattr_file (context, ofd, name, callback) {\n\n  function get_xattr (error, node) {\n    if (error) {\n      return callback(error);\n    }\n\n    var xattrs = node.xattrs;\n\n    if (!xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR());\n    }\n    else {\n      callback(null, xattrs[name]);\n    }\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL());\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else {\n    ofd.getNode(context, get_xattr);\n  }\n}\n\nfunction removexattr_file (context, path, name, callback) {\n  path = normalize(path);\n\n  function remove_xattr (error, node) {\n    if (error) {\n      return callback(error);\n    }\n\n    function update_time(error) {\n      if(error) {\n        callback(error);\n      } else {\n        update_node_times(context, path, node, { ctime: Date.now() }, callback);\n      }\n    }\n\n    var xattrs = node.xattrs;\n\n    if (!xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR(null, path));\n    }\n    else {\n      delete xattrs[name];\n      context.putObject(node.id, node, update_time);\n    }\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else {\n    find_node(context, path, remove_xattr);\n  }\n}\n\nfunction fremovexattr_file (context, ofd, name, callback) {\n\n  function remove_xattr (error, node) {\n    if (error) {\n      return callback(error);\n    }\n\n    function update_time(error) {\n      if(error) {\n        callback(error);\n      } else {\n        update_node_times(context, ofd.path, node, { ctime: Date.now() }, callback);\n      }\n    }\n\n    var xattrs = node.xattrs;\n\n    if (!xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR());\n    }\n    else {\n      delete xattrs[name];\n      context.putObject(node.id, node, update_time);\n    }\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string'));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else {\n    ofd.getNode(context, remove_xattr);\n  }\n}\n\nfunction validate_flags(flags) {\n  return O_FLAGS.hasOwnProperty(flags) ? O_FLAGS[flags] : null;\n}\n\nfunction validate_file_options(options, enc, fileMode){\n  if(!options) {\n    options = { encoding: enc, flag: fileMode };\n  } else if(typeof options === 'function') {\n    options = { encoding: enc, flag: fileMode };\n  } else if(typeof options === 'string') {\n    options = { encoding: options, flag: fileMode };\n  }\n  return options;\n}\n\nfunction open(context, path, flags, mode, callback) {\n  if (arguments.length < 5 ){\n    callback = arguments[arguments.length - 1];\n    mode = 0o644;\n  }\n  else {\n    mode = validateAndMaskMode(mode, FULL_READ_WRITE_EXEC_PERMISSIONS, callback);\n  }\n\n  function check_result(error, fileNode) {\n    if(error) {\n      callback(error);\n    } else {\n      var position;\n      if(flags.includes(O_APPEND)) {\n        position = fileNode.size;\n      } else {\n        position = 0;\n      }\n      var openFileDescription = new OpenFileDescription(path, fileNode.id, flags, position);\n      var fd = openFiles.allocDescriptor(openFileDescription);\n      callback(null, fd);\n    }\n  }\n\n  flags = validate_flags(flags);\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid'), path);\n  }\n\n  open_file(context, path, flags, mode, check_result);\n}\n\nfunction close(context, fd, callback) {\n  if(!openFiles.getOpenFileDescription(fd)) {\n    callback(new Errors.EBADF());\n  } else {\n    openFiles.releaseDescriptor(fd);\n    callback(null);\n  }\n}\n\nfunction mknod(context, path, type, callback) {\n  make_node(context, path, type, callback);\n}\n\nfunction mkdir(context, path, mode, callback) {\n  if (arguments.length < 4) {\n    callback = mode;\n    mode = FULL_READ_WRITE_EXEC_PERMISSIONS;\n  } else {\n    mode = validateAndMaskMode(mode, FULL_READ_WRITE_EXEC_PERMISSIONS, callback);\n    if(!mode) return;\n  }\n \n  make_directory(context, path, callback);\n}\n\nfunction access(context, path, mode, callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = Constants.fsConstants.F_OK;\n  }\n\n  mode = mode | Constants.fsConstants.F_OK;\n  access_file(context, path, mode, callback);\n}\n\nfunction mkdtemp(context, prefix, options, callback) {\n  callback = arguments[arguments.length - 1];\n  if(!prefix) {\n    return callback(new Error('filename prefix is required'));\n  } \n\n  let random = shared.randomChars(6);\n  var path = prefix + '-' + random; \n\n  make_directory(context, path, function(error) {\n    callback(error, path);\n  });  \n}\n\nfunction rmdir(context, path, callback) {\n  remove_directory(context, path, callback);\n}\n\nfunction stat(context, path, callback) {\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(path, result, context.name);\n      callback(null, stats);\n    }\n  }\n\n  stat_file(context, path, check_result);\n}\n\nfunction fstat(context, fd, callback) {\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(ofd.path, result, context.name);\n      callback(null, stats);\n    }\n  }\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else {\n    fstat_file(context, ofd, check_result);\n  }\n}\n\nfunction link(context, oldpath, newpath, callback) {\n  link_node(context, oldpath, newpath, callback);\n}\n\nfunction unlink(context, path, callback) {\n  unlink_node(context, path, callback);\n}\n\nfunction read(context, fd, buffer, offset, length, position, callback) {\n  // Follow how node.js does this\n  function wrapped_cb(err, bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err, bytesRead || 0, buffer);\n  }\n\n  offset = (undefined === offset) ? 0 : offset;\n  length = (undefined === length) ? buffer.length - offset : length;\n  callback = arguments[arguments.length - 1];\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_READ)) {\n    callback(new Errors.EBADF('descriptor does not permit reading'));\n  } else {\n    read_data(context, ofd, buffer, offset, length, position, wrapped_cb);\n  }\n}\n\nfunction fsync(context, fd, callback) {\n  if(validateInteger(fd, callback) !== fd) return;\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else {\n    callback();\n  }\n}\n\nfunction readFile(context, path, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, null, 'r');\n\n  var flags = validate_flags(options.flag || 'r');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, 0);\n    var fd = openFiles.allocDescriptor(ofd);\n\n    function cleanup() {\n      openFiles.releaseDescriptor(fd);\n    }\n\n    fstat_file(context, ofd, function(err, fstatResult) {\n      if(err) {\n        cleanup();\n        return callback(err);\n      }\n\n      var stats = new Stats(ofd.path, fstatResult, context.name);\n\n      if(stats.isDirectory()) {\n        cleanup();\n        return callback(new Errors.EISDIR('illegal operation on directory', path));\n      }\n\n      var size = stats.size;\n      var buffer = Buffer.alloc(size);\n\n      read_data(context, ofd, buffer, 0, size, 0, function(err) {\n        cleanup();\n\n        if(err) {\n          return callback(err);\n        }\n\n        var data;\n        if(options.encoding === 'utf8') {\n          data = buffer.toString('utf8');\n        } else {\n          data = buffer;\n        }\n        callback(null, data);\n      });\n    });\n  });\n}\n\nfunction write(context, fd, buffer, offset, length, position, callback) {\n  callback = arguments[arguments.length - 1];\n  offset = (undefined === offset) ? 0 : offset;\n  length = (undefined === length) ? buffer.length - offset : length;\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else if(buffer.length - offset < length) {\n    callback(new Errors.EIO('input buffer is too small'));\n  } else {\n    write_data(context, ofd, buffer, offset, length, position, callback);\n  }\n}\n\nfunction writeFile(context, path, data, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, 'utf8', 'w');\n\n  var flags = validate_flags(options.flag || 'w');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  data = data || '';\n  if(typeof data === 'number') {\n    data = '' + data;\n  }\n  if(typeof data === 'string' && options.encoding === 'utf8') {\n    data = Buffer.from(data);\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, 0);\n    var fd = openFiles.allocDescriptor(ofd);\n\n    replace_data(context, ofd, data, 0, data.length, function(err) {\n      openFiles.releaseDescriptor(fd);\n\n      if(err) {\n        return callback(err);\n      }\n      callback(null);\n    });\n  });\n}\n\nfunction appendFile(context, path, data, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, 'utf8', 'a');\n\n  var flags = validate_flags(options.flag || 'a');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  data = data || '';\n  if(typeof data === 'number') {\n    data = '' + data;\n  }\n  if(typeof data === 'string' && options.encoding === 'utf8') {\n    data = Buffer.from(data);\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, fileNode.size);\n    var fd = openFiles.allocDescriptor(ofd);\n\n    write_data(context, ofd, data, 0, data.length, ofd.position, function(err) {\n      openFiles.releaseDescriptor(fd);\n\n      if(err) {\n        return callback(err);\n      }\n      callback(null);\n    });\n  });\n}\n\nfunction exists(context, path, callback) {\n  function cb(err) {\n    callback(err ? false : true);\n  }\n  stat(context, path, cb);\n}\n\nfunction validateInteger(value, callback) {\n  if (typeof value !== 'number') {\n    callback(new Errors.EINVAL('Expected integer', value));\n    return;\n  }\n\n  return value;\n}\n\n// Based on https://github.com/nodejs/node/blob/c700cc42da9cf73af9fec2098520a6c0a631d901/lib/internal/validators.js#L21\nvar octalReg = /^[0-7]+$/;\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n// Validator for mode_t (the S_* constants). Valid numbers or octal strings\n// will be masked with 0o777 to be consistent with the behavior in POSIX APIs.\nfunction validateAndMaskMode(value, def, callback) {\n  if(typeof def === 'function') {\n    callback = def;\n    def = undefined;\n  }\n\n  if (isUint32(value)) {\n    return value & FULL_READ_WRITE_EXEC_PERMISSIONS;\n  }\n\n  if (typeof value === 'number') {\n    if (!Number.isInteger(value)) {\n      callback(new Errors.EINVAL('mode not a valid an integer value', value));\n      return false;\n    } else {\n      // 2 ** 32 === 4294967296\n      callback(new Errors.EINVAL('mode not a valid an integer value', value));\n      return false;\n    }\n  }\n\n  if (typeof value === 'string') {\n    if (!octalReg.test(value)) {\n      callback(new Errors.EINVAL('mode not a valid octal string', value));\n      return false;\n    }\n    var parsed = parseInt(value, 8);\n    return parsed & FULL_READ_WRITE_EXEC_PERMISSIONS;\n  }\n\n  // TODO(BridgeAR): Only return `def` in case `value === null`\n  if (def !== undefined) {\n    return def;\n  }\n\n  callback(new Errors.EINVAL('mode not valid', value));\n  return false;\n}\n\nfunction chmod_file(context, path, mode, callback) {\n  path = normalize(path);\n\n  function update_mode(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      node.mode = mode;\n      update_node_times(context, path, node, { mtime: Date.now() }, callback);\n    }\n  }\n\n  if (typeof mode !== 'number') {\n    callback(new Errors.EINVAL('mode must be number', path));\n  }\n  else {\n    find_node(context, path, update_mode);\n  }\n}\n\nfunction fchmod_file(context, ofd, mode, callback) {\n  function update_mode(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      node.mode = mode;\n      update_node_times(context, ofd.path, node, { mtime: Date.now() }, callback);\n    }\n  }\n\n  if (typeof mode !== 'number') {\n    callback(new Errors.EINVAL('mode must be a number'));\n  }\n  else {\n    ofd.getNode(context, update_mode);\n  }\n}\n\nfunction chown_file(context, path, uid, gid, callback) {\n  path = normalize(path);\n\n  function update_owner(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      node.uid = uid;\n      node.gid = gid;\n      update_node_times(context, path, node, { mtime: Date.now() }, callback);\n    }\n  }\n\n  find_node(context, path, update_owner);\n}\n\nfunction fchown_file(context, ofd, uid, gid, callback) {\n  function update_owner(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      node.uid = uid;\n      node.gid = gid;\n      update_node_times(context, ofd.path, node, { mtime: Date.now() }, callback);\n    }\n  }\n\n  ofd.getNode(context, update_owner);\n}\n\nfunction getxattr(context, path, name, callback) {\n  getxattr_file(context, path, name, callback);\n}\n\nfunction fgetxattr(context, fd, name, callback) {\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else {\n    fgetxattr_file(context, ofd, name, callback);\n  }\n}\n\nfunction setxattr(context, path, name, value, flag, callback) {\n  if(typeof flag === 'function') {\n    callback = flag;\n    flag = null;\n  }\n\n  setxattr_file(context, path, name, value, flag, callback);\n}\n\nfunction fsetxattr(context, fd, name, value, flag, callback) {\n  if(typeof flag === 'function') {\n    callback = flag;\n    flag = null;\n  }\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else if (!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  }\n  else {\n    fsetxattr_file(context, ofd, name, value, flag, callback);\n  }\n}\n\nfunction removexattr(context, path, name, callback) {\n  removexattr_file(context, path, name, callback);\n}\n\nfunction fremovexattr(context, fd, name, callback) {\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else if (!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  }\n  else {\n    fremovexattr_file(context, ofd, name, callback);\n  }\n}\n\nfunction lseek(context, fd, offset, whence, callback) {\n  function update_descriptor_position(error, stats) {\n    if(error) {\n      callback(error);\n    } else {\n      if(stats.size + offset < 0) {\n        callback(new Errors.EINVAL('resulting file offset would be negative'));\n      } else {\n        ofd.position = stats.size + offset;\n        callback(null, ofd.position);\n      }\n    }\n  }\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  }\n\n  if('SET' === whence) {\n    if(offset < 0) {\n      callback(new Errors.EINVAL('resulting file offset would be negative'));\n    } else {\n      ofd.position = offset;\n      callback(null, ofd.position);\n    }\n  } else if('CUR' === whence) {\n    if(ofd.position + offset < 0) {\n      callback(new Errors.EINVAL('resulting file offset would be negative'));\n    } else {\n      ofd.position += offset;\n      callback(null, ofd.position);\n    }\n  } else if('END' === whence) {\n    fstat_file(context, ofd, update_descriptor_position);\n  } else {\n    callback(new Errors.EINVAL('whence argument is not a proper value'));\n  }\n}\n\nfunction readdir(context, path, callback) {\n  read_directory(context, path, callback);\n}\n\nfunction toUnixTimestamp(time) {\n  if (typeof time === 'number') {\n    return time;\n  }\n  if (typeof time === 'object' && typeof time.getTime === 'function') {\n    return time.getTime() / 1000;\n  }\n}\n\nfunction utimes(context, path, atime, mtime, callback) {\n  var currentTime = Date.now();\n  atime = (atime) ? toUnixTimestamp(atime) : toUnixTimestamp(currentTime);\n  mtime = (mtime) ? toUnixTimestamp(mtime) : toUnixTimestamp(currentTime);\n\n  utimes_file(context, path, atime, mtime, callback);\n}\n\nfunction futimes(context, fd, atime, mtime, callback) {\n  var currentTime = Date.now();\n  atime = (atime) ? toUnixTimestamp(atime) : toUnixTimestamp(currentTime);\n  mtime = (mtime) ? toUnixTimestamp(mtime) : toUnixTimestamp(currentTime);\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    futimes_file(context, ofd, atime, mtime, callback);\n  }\n}\n\nfunction chmod(context, path, mode, callback) {\n  mode = validateAndMaskMode(mode, callback);\n  if(!mode) return;\n\n  chmod_file(context, path, mode, callback);\n}\n\nfunction fchmod(context, fd, mode, callback) {\n  mode = validateAndMaskMode(mode, callback);\n  if(!mode) return;\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    fchmod_file(context, ofd, mode, callback);\n  }\n}\n\nfunction chown(context, path, uid, gid, callback) {\n  if(!isUint32(uid)) {\n    return callback(new Errors.EINVAL('uid must be a valid integer', uid));\n  }\n  if(!isUint32(gid)) {\n    return callback(new Errors.EINVAL('gid must be a valid integer', gid));\n  }\n\n  chown_file(context, path, uid, gid, callback);\n}\n\nfunction fchown(context, fd, uid, gid, callback) {\n  if(!isUint32(uid)) {\n    return callback(new Errors.EINVAL('uid must be a valid integer', uid));\n  }\n  if(!isUint32(gid)) {\n    return callback(new Errors.EINVAL('gid must be a valid integer', gid));\n  }\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    fchown_file(context, ofd, uid, gid, callback);\n  }\n}\n\nfunction rename(context, oldpath, newpath, callback) {\n  oldpath = normalize(oldpath);\n  newpath = normalize(newpath);\n\n  var oldParentPath = Path.dirname(oldpath);\n  var newParentPath = Path.dirname(oldpath);\n  var oldName = Path.basename(oldpath);\n  var newName = Path.basename(newpath);\n  var oldParentDirectory, oldParentData;\n  var newParentDirectory, newParentData;\n  var ctime = Date.now();\n  var fileNode;\n\n  function update_times(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      update_node_times(context, newpath, fileNode, { ctime: ctime }, callback);\n    }\n  }\n\n  function read_new_directory(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.getObject(newParentData[newName].id, update_times);\n    }\n  }\n\n  function update_old_parent_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      if(oldParentDirectory.id === newParentDirectory.id) {\n        oldParentData = newParentData;\n      }\n      delete oldParentData[oldName];\n      context.putObject(oldParentDirectory.data, oldParentData, read_new_directory);\n    }\n  }\n\n  function update_new_parent_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      newParentData[newName] = oldParentData[oldName];\n      context.putObject(newParentDirectory.data, newParentData, update_old_parent_directory_data);\n    }\n  }\n\n  function check_if_new_directory_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newParentData = result;\n      if(newParentData.hasOwnProperty(newName)) {\n        remove_directory(context, newpath, update_new_parent_directory_data);\n      } else {\n        update_new_parent_directory_data();\n      }\n    }\n  }\n\n  function read_new_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newParentDirectory = result;\n      context.getObject(newParentDirectory.data, check_if_new_directory_exists);\n    }\n  }\n\n  function get_new_parent_directory(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldParentData = result;\n      find_node(context, newParentPath, read_new_parent_directory_data);\n    }\n  }\n\n  function read_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldParentDirectory = result;\n      context.getObject(result.data, get_new_parent_directory);\n    }\n  }\n\n  function unlink_old_file(error) {\n    if(error) {\n      callback(error);\n    } else {\n      unlink_node(context, oldpath, callback);\n    }\n  }\n\n  function check_node_type(error, node) {\n    if(error) {\n      callback(error);\n    } else if(node.type === NODE_TYPE_DIRECTORY) {\n      find_node(context, oldParentPath, read_parent_directory_data);\n    } else {\n      link_node(context, oldpath, newpath, unlink_old_file);\n    }\n  }\n\n  find_node(context, oldpath, check_node_type);\n}\n\nfunction symlink(context, srcpath, dstpath, type, callback) {\n  // NOTE: we support passing the `type` arg, but ignore it.\n  callback = arguments[arguments.length - 1];\n  make_symbolic_link(context, srcpath, dstpath, callback);\n}\n\nfunction readlink(context, path, callback) {\n  read_link(context, path, callback);\n}\n\nfunction lstat(context, path, callback) {\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(path, result, context.name);\n      callback(null, stats);\n    }\n  }\n\n  lstat_file(context, path, check_result);\n}\n\nfunction truncate(context, path, length, callback) {\n  // NOTE: length is optional\n  callback = arguments[arguments.length - 1];\n  length = length || 0;\n\n  if(validateInteger(length, callback) !== length) return;\n\n  truncate_file(context, path, length, callback);\n}\n\nfunction ftruncate(context, fd, length, callback) {\n  // NOTE: length is optional\n  callback = arguments[arguments.length - 1];\n  length = length || 0;\n\n  var ofd = openFiles.getOpenFileDescription(fd);\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    if(validateInteger(length, callback) !== length) return;\n    ftruncate_file(context, ofd, length, callback);\n  }\n}\n\nmodule.exports = {\n  appendFile,\n  access,\n  chown,\n  chmod,\n  close,\n  // copyFile - https://github.com/filerjs/filer/issues/436\n  ensureRootDirectory: ensure_root_directory,\n  exists,\n  fchown,\n  fchmod,\n  // fdatasync - https://github.com/filerjs/filer/issues/653\n  fgetxattr,\n  fremovexattr,\n  fsetxattr,\n  fstat,\n  fsync,\n  ftruncate,\n  futimes,\n  getxattr,\n  // lchown - https://github.com/filerjs/filer/issues/620\n  // lchmod - https://github.com/filerjs/filer/issues/619\n  link,\n  lseek,\n  lstat,\n  mkdir,\n  mkdtemp,\n  mknod,\n  open,\n  readdir,\n  read,\n  readFile,\n  readlink,\n  // realpath - https://github.com/filerjs/filer/issues/85\n  removexattr,\n  rename,\n  rmdir,\n  setxattr,\n  stat,\n  symlink,\n  truncate,\n  // unwatchFile - implemented in interface.js\n  unlink,\n  utimes,\n  // watch - implemented in interface.js\n  // watchFile - implemented in interface.js\n  writeFile,\n  write\n};\n","var { promisify } = require('es6-promisify');\n\nvar Path = require('../path.js');\nvar nop = require('../shared.js').nop;\n\nvar Constants = require('../constants.js');\nvar FILE_SYSTEM_NAME = Constants.FILE_SYSTEM_NAME;\nvar FS_FORMAT = Constants.FS_FORMAT;\nvar FS_READY = Constants.FS_READY;\nvar FS_PENDING = Constants.FS_PENDING;\nvar FS_ERROR = Constants.FS_ERROR;\nvar FS_NODUPEIDCHECK = Constants.FS_NODUPEIDCHECK;\n\nvar providers = require('../providers/index.js');\n\nvar Shell = require('../shell/shell.js');\nvar Intercom = require('../../lib/intercom.js');\nvar FSWatcher = require('../fs-watcher.js');\nvar Errors = require('../errors.js');\nvar defaultGuidFn = require('../shared.js').guid;\n\nvar STDIN = Constants.STDIN;\nvar STDOUT = Constants.STDOUT;\nvar STDERR = Constants.STDERR;\n\n// The core fs operations live on impl\nvar impl = require('./implementation.js');\n\n// node.js supports a calling pattern that leaves off a callback.\nfunction maybeCallback(callback) {\n  if(typeof callback === 'function') {\n    return callback;\n  }\n  return function(err) {\n    if(err) {\n      throw err;\n    }\n  };\n}\n\n// Default callback that logs an error if passed in\nfunction defaultCallback(err) {\n  if(err) {\n    /* eslint no-console: 0 */\n    console.error('Filer error: ', err);\n  }\n}\n// Get a path (String) from a file:// URL. Support URL() like objects\n// https://github.com/nodejs/node/blob/968e901aff38a343b1de4addebf79fd8fa991c59/lib/internal/url.js#L1381\nfunction toPathIfFileURL(fileURLOrPath) {\n  if(!(fileURLOrPath &&\n       fileURLOrPath.protocol &&\n       fileURLOrPath.pathname)) {\n    return fileURLOrPath;\n  }\n\n  if(fileURLOrPath.protocol !== 'file:') {\n    throw new Errors.EINVAL('only file: URLs are supported for paths', fileURLOrPath);\n  }\n\n  var pathname = fileURLOrPath.pathname;\n  for (var n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      var third = pathname.codePointAt(n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        throw new Errors.EINVAL('file: URLs must not include encoded / characters', fileURLOrPath);\n      }\n    }\n  }\n\n  return decodeURIComponent(pathname);\n}\n\n// Allow Buffers for paths. Assumes we want UTF8.\nfunction toPathIfBuffer(bufferOrPath) {\n  return Buffer.isBuffer(bufferOrPath) ? bufferOrPath.toString() : bufferOrPath;\n}\n\nfunction validatePath(path, allowRelative) {\n  if(!path) {\n    return new Errors.EINVAL('Path must be a string', path);\n  } else if(Path.isNull(path)) {\n    return new Errors.EINVAL('Path must be a string without null bytes.', path);\n  } else if(!allowRelative && !Path.isAbsolute(path)) {\n    return new Errors.EINVAL('Path must be absolute.', path);\n  }\n}\n\nfunction processPathArg(args, idx, allowRelative) {\n  var path = args[idx];\n  path = toPathIfFileURL(path);\n  path = toPathIfBuffer(path);\n\n  // Some methods specifically allow for rel paths (eg symlink with srcPath)\n  var err = validatePath(path, allowRelative);\n  if(err) {\n    throw err;\n  }\n\n  // Overwrite path arg with converted and validated path\n  args[idx] = path;\n}\n\n/**\n * FileSystem\n *\n * A FileSystem takes an `options` object, which can specify a number of,\n * options.  All options are optional, and include:\n *\n * name: the name of the file system, defaults to \"local\"\n *\n * flags: one or more flags to use when creating/opening the file system.\n *        For example: \"FORMAT\" will cause the file system to be formatted.\n *        No explicit flags are set by default.\n *\n * provider: an explicit storage provider to use for the file\n *           system's database context provider.  A number of context\n *           providers are included (see /src/providers), and users\n *           can write one of their own and pass it in to be used.\n *           By default an IndexedDB provider is used.\n *\n * guid: a function for generating unique IDs for nodes in the filesystem.\n *       Use this to override the built-in UUID generation. (Used mainly for tests).\n *\n * callback: a callback function to be executed when the file system becomes\n *           ready for use. Depending on the context provider used, this might\n *           be right away, or could take some time. The callback should expect\n *           an `error` argument, which will be null if everything worked.  Also\n *           users should check the file system's `readyState` and `error`\n *           properties to make sure it is usable.\n */\nfunction FileSystem(options, callback) {\n  options = options || {};\n  callback = callback || defaultCallback;\n\n  var flags = options.flags || [];\n  var guid = options.guid ? options.guid : defaultGuidFn;\n  var provider = options.provider || new providers.Default(options.name || FILE_SYSTEM_NAME);\n  // If we're given a provider, match its name unless we get an explicit name\n  var name = options.name || provider.name;\n  var forceFormatting = flags.includes(FS_FORMAT);\n\n  var fs = this;\n  fs.readyState = FS_PENDING;\n  fs.name = name;\n  fs.error = null;\n\n  fs.stdin = STDIN;\n  fs.stdout = STDOUT;\n  fs.stderr = STDERR;\n\n  // Expose Node's fs.constants to users\n  fs.constants = Constants.fsConstants;\n  // Node also forwards the access mode flags onto fs\n  fs.F_OK = Constants.fsConstants.F_OK;\n  fs.R_OK = Constants.fsConstants.R_OK;\n  fs.W_OK = Constants.fsConstants.W_OK;\n  fs.X_OK = Constants.fsConstants.X_OK;\n\n  // Expose Shell constructor\n  this.Shell = Shell.bind(undefined, this);\n\n  // Safely expose the operation queue\n  var queue = [];\n  this.queueOrRun = function(operation) {\n    var error;\n\n    if(FS_READY === fs.readyState) {\n      operation.call(fs);\n    } else if(FS_ERROR === fs.readyState) {\n      error = new Errors.EFILESYSTEMERROR('unknown error');\n    } else {\n      queue.push(operation);\n    }\n\n    return error;\n  };\n  function runQueued() {\n    queue.forEach(function(operation) {\n      operation.call(this);\n    }.bind(fs));\n    queue = null;\n  }\n\n  // We support the optional `options` arg from node, but ignore it\n  this.watch = function(filename, options, listener) {\n    if(Path.isNull(filename)) {\n      throw new Error('Path must be a string without null bytes.');\n    }\n    if(typeof options === 'function') {\n      listener = options;\n      options = {};\n    }\n    options = options || {};\n    listener = listener || nop;\n\n    var watcher = new FSWatcher();\n    watcher.start(filename, false, options.recursive);\n    watcher.on('change', listener);\n\n    return watcher;\n  };\n\n  // Deal with various approaches to node ID creation\n  function wrappedGuidFn(context) {\n    return function(callback) {\n      // Skip the duplicate ID check if asked to\n      if(flags.includes(FS_NODUPEIDCHECK)) {\n        callback(null, guid());\n        return;\n      }\n\n      // Otherwise (default) make sure this id is unused first\n      function guidWithCheck(callback) {\n        var id = guid();\n        context.getObject(id, function(err, value) {\n          if(err) {\n            callback(err);\n            return;\n          }\n\n          // If this id is unused, use it, otherwise find another\n          if(!value) {\n            callback(null, id);\n          } else {\n            guidWithCheck(callback);\n          }\n        });\n      }\n      guidWithCheck(callback);\n    };\n  }\n\n  // Let other instances (in this or other windows) know about\n  // any changes to this fs instance.\n  function broadcastChanges(changes) {\n    if(!changes.length) {\n      return;\n    }\n    var intercom = Intercom.getInstance();\n    changes.forEach(function(change) {\n      intercom.emit(change.event, change.path);\n    });\n  }\n\n  // Open file system storage provider\n  provider.open(function(err) {\n    function complete(error) {\n      function wrappedContext(methodName) {\n        var context = provider[methodName]();\n        context.name = name;\n        context.flags = flags;\n        context.changes = [];\n        context.guid = wrappedGuidFn(context);\n\n        // When the context is finished, let the fs deal with any change events\n        context.close = function() {\n          var changes = context.changes;\n          broadcastChanges(changes);\n          changes.length = 0;\n        };\n\n        return context;\n      }\n\n      // Wrap the provider so we can extend the context with fs flags and\n      // an array of changes (e.g., watch event 'change' and 'rename' events\n      // for paths updated during the lifetime of the context). From this\n      // point forward we won't call open again, so it's safe to drop it.\n      fs.provider = {\n        openReadWriteContext: function() {\n          return wrappedContext('getReadWriteContext');\n        },\n        openReadOnlyContext: function() {\n          return wrappedContext('getReadOnlyContext');\n        }\n      };\n\n      if(error) {\n        fs.readyState = FS_ERROR;\n      } else {\n        fs.readyState = FS_READY;\n      }\n      runQueued();\n      callback(error, fs);\n    }\n\n    if(err) {\n      return complete(err);\n    }\n\n    var context = provider.getReadWriteContext();\n    context.guid = wrappedGuidFn(context);\n\n    // Mount the filesystem, formatting if necessary\n    if(forceFormatting) {\n      // Wipe the storage provider, then write root block\n      context.clear(function(err) {\n        if(err) {\n          return complete(err);\n        }\n        impl.ensureRootDirectory(context, complete);\n      });\n    } else {\n      // Use existing (or create new) root and mount\n      impl.ensureRootDirectory(context, complete);\n    }\n  });\n  FileSystem.prototype.promises = {};\n\n  /**\n   * Public API for FileSystem. All node.js methods that are exposed on fs.promises\n   * include `promise: true`.  We also include our own extra methods, but skip the\n   * fd versions to match node.js, which puts these on a `FileHandle` object.\n   * Any method that deals with path argument(s) also includes the position of\n   * those args in one of `absPathArgs: [...]` or `relPathArgs: [...]`, so they\n   * can be processed and validated before being passed on to the method.\n   */\n  [\n    { name: 'appendFile', promises: true, absPathArgs: [ 0 ] },\n    { name: 'access', promises: true, absPathArgs: [ 0 ] },\n    { name: 'chown', promises: true, absPathArgs: [ 0 ] },\n    { name: 'chmod', promises: true, absPathArgs: [ 0 ] },\n    { name: 'close' },\n    // copyFile - https://github.com/filerjs/filer/issues/436\n    { name: 'exists', absPathArgs: [ 0 ] },\n    { name: 'fchown' },\n    { name: 'fchmod' },\n    // fdatasync - https://github.com/filerjs/filer/issues/653\n    { name: 'fgetxattr' },\n    { name: 'fremovexattr' },\n    { name: 'fsetxattr' },\n    { name: 'fstat' },\n    { name: 'fsync' },\n    { name: 'ftruncate' },\n    { name: 'futimes' },\n    { name: 'getxattr', promises: true, absPathArgs: [ 0 ] },\n    // lchown - https://github.com/filerjs/filer/issues/620\n    // lchmod - https://github.com/filerjs/filer/issues/619\n    { name: 'link', promises: true, absPathArgs: [0, 1] },\n    { name: 'lseek' },\n    { name: 'lstat', promises: true },\n    { name: 'mkdir', promises: true, absPathArgs: [ 0 ] },\n    { name: 'mkdtemp', promises: true },\n    { name: 'mknod', promises: true, absPathArgs: [ 0 ] },\n    { name: 'open', promises: true, absPathArgs: [ 0 ] },\n    { name: 'readdir', promises: true, absPathArgs: [ 0 ] },\n    { name: 'read' },\n    { name: 'readFile', promises: true, absPathArgs: [ 0 ] },\n    { name: 'readlink', promises: true, absPathArgs: [ 0 ] },\n    // realpath - https://github.com/filerjs/filer/issues/85\n    { name: 'removexattr', promises: true, absPathArgs: [ 0 ] },\n    { name: 'rename', promises: true, absPathArgs: [0, 1] },\n    { name: 'rmdir', promises: true, absPathArgs: [ 0 ] },\n    { name: 'setxattr', promises: true, absPathArgs: [ 0 ] },\n    { name: 'stat', promises: true, absPathArgs: [ 0 ] },\n    { name: 'symlink', promises: true, relPathArgs: [ 0 ], absPathArgs: [ 1 ] },\n    { name: 'truncate', promises: true, absPathArgs: [ 0 ] },\n    // unwatchFile - https://github.com/filerjs/filer/pull/553\n    { name: 'unlink', promises: true, absPathArgs: [ 0 ] },\n    { name: 'utimes', promises: true, absPathArgs: [ 0 ] },\n    // watch - implemented above in `this.watch`\n    // watchFile - https://github.com/filerjs/filer/issues/654\n    { name: 'writeFile', promises: true, absPathArgs: [ 0 ] },\n    { name: 'write' }\n  ].forEach(function(method) {\n    var methodName = method.name;\n    var shouldPromisify = method.promises === true;\n\n    FileSystem.prototype[methodName] = function() {\n      var fs = this;\n      var args = Array.prototype.slice.call(arguments, 0);\n      var lastArgIndex = args.length - 1;\n\n      // We may or may not get a callback, and since node.js supports\n      // fire-and-forget style fs operations, we have to dance a bit here.\n      var missingCallback = typeof args[lastArgIndex] !== 'function';\n      var callback = maybeCallback(args[lastArgIndex]);\n\n      // Deal with path arguments, validating and normalizing Buffer and file:// URLs\n      if(method.absPathArgs) {\n        method.absPathArgs.forEach(pathArg => processPathArg(args, pathArg, false));\n      }\n      if(method.relPathArgs) {\n        method.relPathArgs.forEach(pathArg => processPathArg(args, pathArg, true));\n      }\n\n      var error = fs.queueOrRun(function() {\n        var context = fs.provider.openReadWriteContext();\n\n        // Fail early if the filesystem is in an error state (e.g.,\n        // provider failed to open.\n        if(FS_ERROR === fs.readyState) {\n          var err = new Errors.EFILESYSTEMERROR('filesystem unavailable, operation canceled');\n          return callback.call(fs, err);\n        }\n\n        // Wrap the callback so we can explicitly close the context\n        function complete() {\n          context.close();\n          callback.apply(fs, arguments);\n        }\n\n        // Either add or replace the callback with our wrapper complete()\n        if(missingCallback) {\n          args.push(complete);\n        } else {\n          args[lastArgIndex] = complete;\n        }\n\n        // Forward this call to the impl's version, using the following\n        // call signature, with complete() as the callback/last-arg now:\n        // fn(fs, context, arg0, arg1, ... , complete);\n        var fnArgs = [context].concat(args);\n        impl[methodName].apply(null, fnArgs);\n      });\n      if(error) {\n        callback(error);\n      }\n    };\n    \n    // Add to fs.promises if appropriate\n    if(shouldPromisify) {\n      FileSystem.prototype.promises[methodName] = promisify(FileSystem.prototype[methodName].bind(fs));\n    }\n  });\n\n}\n\n// Expose storage providers on FileSystem constructor\nFileSystem.providers = providers;\n\nmodule.exports = FileSystem;\n","let fs = null;\nlet Filer = null;\n\nmodule.exports = Filer = {\n  FileSystem: require('./filesystem/interface.js'),\n  Buffer: Buffer,\n  // We previously called this Path, but node calls it path. Do both\n  Path: require('./path.js'),\n  path: require('./path.js'),\n  Errors: require('./errors.js'),\n  Shell: require('./shell/shell.js')\n};\n\n// Add a getter for the `fs` instance, which returns\n// a Filer FileSystem instance, using the default provider/flags.\nObject.defineProperty(Filer, 'fs', {\n  enumerable: true,\n  get() {\n    if(!fs) {\n      fs = new Filer.FileSystem();\n    }\n    return fs;\n  }\n});\n"]}